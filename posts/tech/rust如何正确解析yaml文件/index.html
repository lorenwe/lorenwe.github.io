<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust如何正确解析yaml文件 | Lorenwe Blog</title><meta name=keywords content><meta name=description content="一、简介
serde_yaml 是 Rust 语言中一个用于序列化和反序列化 YAML 数据的库。它以其高性能和灵活性而广受欢迎，特别适用于需要处理 YAML 配置文件的项目。在这篇博客中，我们将探讨 serde_yaml 的基本用法，并提供一些实用的示例代码。
二、使用场景
serde_yaml 常用于以下场景：

配置管理：许多应用程序使用 YAML 文件来存储配置参数，serde_yaml 可以轻松解析这些文件。
数据交换：在系统之间传递数据时，YAML 格式因其可读性而常被选用。
文档生成：一些工具使用 YAML 来描述文档结构，serde_yaml 可以帮助生成和解析这些文档。

三、基本使用
开始使用 serde_yaml 之前，先创建一个 serde_yaml_test 项目文件夹，在文件夹中使用 cargo init 初始化 rust 项目，然后在项目的 Cargo.toml 文件中添加依赖："><meta name=author content="Lorenwe"><link rel=canonical href=https://lorenwe.eu.org/posts/tech/rust%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%A7%A3%E6%9E%90yaml%E6%96%87%E4%BB%B6/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://lorenwe.eu.org/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lorenwe.eu.org/img/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://lorenwe.eu.org/img/favicon.ico><link rel=apple-touch-icon href=https://lorenwe.eu.org/img/favicon.ico><link rel=mask-icon href=https://lorenwe.eu.org/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://lorenwe.eu.org/posts/tech/rust%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%A7%A3%E6%9E%90yaml%E6%96%87%E4%BB%B6/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js></script><link rel=stylesheet href=https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/4.7.0/css/font-awesome.min.css><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script src=https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js></script><meta property="og:title" content="Rust如何正确解析yaml文件"><meta property="og:description" content="一、简介
serde_yaml 是 Rust 语言中一个用于序列化和反序列化 YAML 数据的库。它以其高性能和灵活性而广受欢迎，特别适用于需要处理 YAML 配置文件的项目。在这篇博客中，我们将探讨 serde_yaml 的基本用法，并提供一些实用的示例代码。
二、使用场景
serde_yaml 常用于以下场景：

配置管理：许多应用程序使用 YAML 文件来存储配置参数，serde_yaml 可以轻松解析这些文件。
数据交换：在系统之间传递数据时，YAML 格式因其可读性而常被选用。
文档生成：一些工具使用 YAML 来描述文档结构，serde_yaml 可以帮助生成和解析这些文档。

三、基本使用
开始使用 serde_yaml 之前，先创建一个 serde_yaml_test 项目文件夹，在文件夹中使用 cargo init 初始化 rust 项目，然后在项目的 Cargo.toml 文件中添加依赖："><meta property="og:type" content="article"><meta property="og:url" content="https://lorenwe.eu.org/posts/tech/rust%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%A7%A3%E6%9E%90yaml%E6%96%87%E4%BB%B6/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-23T11:14:01+08:00"><meta property="article:modified_time" content="2024-10-23T11:14:01+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust如何正确解析yaml文件"><meta name=twitter:description content="一、简介
serde_yaml 是 Rust 语言中一个用于序列化和反序列化 YAML 数据的库。它以其高性能和灵活性而广受欢迎，特别适用于需要处理 YAML 配置文件的项目。在这篇博客中，我们将探讨 serde_yaml 的基本用法，并提供一些实用的示例代码。
二、使用场景
serde_yaml 常用于以下场景：

配置管理：许多应用程序使用 YAML 文件来存储配置参数，serde_yaml 可以轻松解析这些文件。
数据交换：在系统之间传递数据时，YAML 格式因其可读性而常被选用。
文档生成：一些工具使用 YAML 来描述文档结构，serde_yaml 可以帮助生成和解析这些文档。

三、基本使用
开始使用 serde_yaml 之前，先创建一个 serde_yaml_test 项目文件夹，在文件夹中使用 cargo init 初始化 rust 项目，然后在项目的 Cargo.toml 文件中添加依赖："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚文章","item":"https://lorenwe.eu.org/posts/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻 技术","item":"https://lorenwe.eu.org/posts/tech/"},{"@type":"ListItem","position":3,"name":"Rust如何正确解析yaml文件","item":"https://lorenwe.eu.org/posts/tech/rust%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%A7%A3%E6%9E%90yaml%E6%96%87%E4%BB%B6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust如何正确解析yaml文件","name":"Rust如何正确解析yaml文件","description":"一、简介 serde_yaml 是 Rust 语言中一个用于序列化和反序列化 YAML 数据的库。它以其高性能和灵活性而广受欢迎，特别适用于需要处理 YAML 配置文件的项目。在这篇博客中，我们将探讨 serde_yaml 的基本用法，并提供一些实用的示例代码。\n二、使用场景 serde_yaml 常用于以下场景：\n配置管理：许多应用程序使用 YAML 文件来存储配置参数，serde_yaml 可以轻松解析这些文件。 数据交换：在系统之间传递数据时，YAML 格式因其可读性而常被选用。 文档生成：一些工具使用 YAML 来描述文档结构，serde_yaml 可以帮助生成和解析这些文档。 三、基本使用 开始使用 serde_yaml 之前，先创建一个 serde_yaml_test 项目文件夹，在文件夹中使用 cargo init 初始化 rust 项目，然后在项目的 Cargo.toml 文件中添加依赖：\n","keywords":[""],"articleBody":"一、简介 serde_yaml 是 Rust 语言中一个用于序列化和反序列化 YAML 数据的库。它以其高性能和灵活性而广受欢迎，特别适用于需要处理 YAML 配置文件的项目。在这篇博客中，我们将探讨 serde_yaml 的基本用法，并提供一些实用的示例代码。\n二、使用场景 serde_yaml 常用于以下场景：\n配置管理：许多应用程序使用 YAML 文件来存储配置参数，serde_yaml 可以轻松解析这些文件。 数据交换：在系统之间传递数据时，YAML 格式因其可读性而常被选用。 文档生成：一些工具使用 YAML 来描述文档结构，serde_yaml 可以帮助生成和解析这些文档。 三、基本使用 开始使用 serde_yaml 之前，先创建一个 serde_yaml_test 项目文件夹，在文件夹中使用 cargo init 初始化 rust 项目，然后在项目的 Cargo.toml 文件中添加依赖：\nserde = { version = \"1.0\", features = [\"derive\"] } serde_yaml = \"0.9.34\" 要使用最新版本的 serde 的话可以使用命令行来添加依赖，如：\ncargo add serde --features=\"derive\" cargo add serde_yaml 依赖的包都准备完成后，就来看看几个示例，演示如何读取、解析和生成 YAML 文件。\n1、读取和解析 YAML 文件 以下是一个基本示例，展示了如何使用 serde_yaml 读取和解析一个名为 以下是一个基本示例，展示了如何使用 serde_yaml 读取和解析一个名为 hello.yml 的文件： 的文件：\n# 在项目根目录创建一个 hello.yml 文件 touch hello.yml # 此时目录结构为 #|-serde_yaml_test # |--src # |--target # |--.gitignore # |--Cargo.lock # |--Cargo.toml # |--hello.yml use std::collections::BTreeMap; use std::fs::File; use std::io::Read; use serde_yaml; fn main() -\u003e Result\u003c(), Box\u003e { let mut file = File::open(\"hello.yml\")?; // 打开文件 hello.yml let mut contents = String::new(); // 创建一个字符串 file.read_to_string(\u0026mut contents)?; // 读取文件内容到字符串缓冲区 println!(\"YAML file contents:\\n{}\", contents); // 打印原始的YAML字符串 // 将YAML字符串反序列化为BTreeMap let deserialized_map: BTreeMap = serde_yaml::from_str(\u0026contents)?; println!(\"Deserialized map: {:#?}\", deserialized_map); // 打印反序列化后的数据结构 if let Some(name) = deserialized_map.get(\"name\").and_then(|v| v.as_str()) { println!(\"name: {}\", name); // 打印 name } else { println!(\"The key 'name' was not found or is not a string.\"); } Ok(()) } // 输出结果： // Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.03s // Running `target\\debug\\serde_yaml_test.exe` // YAML file contents: // name: data // Deserialized map: { // \"name\": String(\"data\"), // } // name: data 2、序列化数据结构为 YAML 示例展示了如何将一个 Rust 数据结构序列化为 YAML 格式的字符串：\nuse std::collections::BTreeMap; use serde_yaml; fn main() -\u003e Result\u003c(), Box\u003e { // 创建一个 BTreeMap 数据结构 let mut data = BTreeMap::new(); data.insert(\"name\".to_string(), serde_yaml::Value::String(\"Alice\".to_string())); data.insert(\"age\".to_string(), serde_yaml::Value::Number(serde_yaml::Number::from(30))); // 将数据结构序列化为 YAML 字符串 let yaml_string = serde_yaml::to_string(\u0026data)?; // 打印序列化后的 YAML 字符串 println!(\"Serialized YAML:\\n{}\", yaml_string); Ok(()) } 3、使用自定义结构体进行反序列化 使用自定义结构体来解析 YAML 数据会更加方便和直观。以下示例展示了如何定义一个结构体并解析 YAML 数据：\nuse serde::{Deserialize, Serialize}; use serde_yaml; #[derive(Debug, Serialize, Deserialize)] struct Person { name: String, age: u8, } fn main() -\u003e Result\u003c(), Box\u003e { // 定义一个 YAML 字符串 let yaml_str = \" name: Bob age: 25 \"; // 将 YAML 字符串反序列化为 Person 结构体 let person: Person = serde_yaml::from_str(yaml_str)?; // 打印反序列化后的结构体 println!(\"Deserialized person: {:?}\", person); Ok(()) } 4、从文件流中直接解析 有时，为了优化内存使用，可以直接从文件流中进行解析：\nuse serde::{Deserialize, Serialize}; use std::fs::File; #[derive(Debug, Serialize, Deserialize)] struct Config { database_url: String, port: u16, } fn main() -\u003e Result\u003c(), Box\u003e { // 打开配置文件 let file = File::open(\"config.yml\")?; // 从文件流中直接反序列化 let config: Config = serde_yaml::from_reader(file)?; // 打印反序列化后的配置 println!(\"Config: {:?}\", config); Ok(()) } 四、复杂 YAML 文件解析 基于以上案例，来尝试解析一个复杂的 yaml 文件，既然要复杂，那就尝试解析一下 docker-compose.yml文件吧！先来准备一个 yaml 文件，放在项目根目录下，如下：\nversion: \"3.9\" services: redis: image: redis:latest restart: always privileged: true ports: - 6379:6379 volumes: - ./data/redis/data:/data - ./redis/etc:/usr/local/etc/redis command: redis-server /usr/local/etc/redis/redis.conf nginx: image: nginx:latest restart: always privileged: true volumes: - ./nginx/etc/nginx:/etc/nginx - ./var/www:/var/www/html ports: - \"80:80\" - \"443:443\" depends_on: - redis networks: mynet1: driver: overlay attachable: false 再写代码之前，先把 rust 引入的包先贴出来，后面贴代码时可以少写一点啰嗦代码，只关注核心逻辑，看起来更清晰易懂，这是整个项目所依赖的包，也没有很多\nuse std::collections::HashMap; use std::fmt::{Debug, Display}; use std::fs::File; use std::io::Read; use serde::{Deserialize, Serialize}; 1.固定字段解析 整个 yml 文件看下来，并没有很多，但算是一个比较全面的 docker-compose 配置文件了，虽然没有用到所有的配置字段，触类旁通，再多的配置字段都能轻车熟路的解析吧，先一级一级的看，一级有 version services networks，通过以上，就可以定义出需要的结构体了：\n#[derive(Debug, Serialize, Deserialize)] struct DockerYaml { version: String, services: HashMap, } 这里的 services 的类型用的是 HashMap，因为 services 名称是一个变量，而且数量不固定，比如还可以增加 mysql 服务，所以 services 是一个动态，services 里面又引入了 ServiceCfg 类型，现在继续看 services 下一级的配置字段，其中 image 是必须要存在的配置，那 ServiceCfg 结构体可以定义成：\n#[derive(Debug, Clone, Serialize, Deserialize)] struct ServiceCfg { image: String, } 好了，就这么简单，先写个 main 函数把代码跑起来看看吧！\nfn main() -\u003e Result\u003c(), Box\u003e { let mut file = File::open(\"docker-compose.yml\")?; // 打开文件 let mut contents = String::new(); // 创建一个字符串 file.read_to_string(\u0026mut contents)?; // 读取文件内容到字符串缓冲区 // println!(\"读取到的 YAML 内容:\\n{}\", contents); // 打印原始的YAML字符串 // 将 YAML 字符串反序列化为 DockerYaml 结构体 let docker_yaml: DockerYaml = serde_yaml::from_str(\u0026contents)?; // 打印反序列化后的结构体 println!(\"反序列化后的结构体: {:?}\", docker_yaml); // 读取出 services let services = \u0026docker_yaml.services; for (serve, config) in services { println!(\"services name: {}\", serve); println!(\"services config: {:?}\", config); } Ok(()) } // 打印的内容： // 反序列化后的结构体: DockerYaml { version: \"3.9\", services: {\"nginx\": ServiceCfg { image: \"nginx:latest\" }, \"redis\": ServiceCfg { image: \"redis:latest\" }} } // services name: nginx // services config: ServiceCfg { image: \"nginx:latest\" } // services name: redis // services config: ServiceCfg { image: \"redis:latest\" } 正常打印了，现在可以完善 ServiceCfg 这个结构体了\n2.动态字段解析 docker-compose 配置的 services 中，大部分配置都可选的，如果不配置，就会有个默认值，先不关心这个默认值是什么，但起码要实现一个不配置会有默认值的功能，带着疑问，先去写一下代码，\n把 ServiceCfg 结构体修改成以下的样子：\n#[derive(Debug, Clone, Serialize, Deserialize)] struct ServiceCfg { image: String, restart: String, } 只是添加了一个 restart 配置项，main 函数不变，cargo run 一下发现正常打印了如下：\n反序列化后的结构体: DockerYaml { version: \"3.9\", services: {\"nginx\": ServiceCfg { image: \"nginx:latest\", restart: \"always\" }, \"redis\": ServiceCfg { image: \"redis:latest\", restart: \"always\" }} } services name: nginx services config: ServiceCfg { image: \"nginx:latest\", restart: \"always\" } services name: redis services config: ServiceCfg { image: \"redis:latest\", restart: \"always\" } restart 配置项正常读取到了，好像一切都很完美，但 restart 配置是个可选配置，那在 docker-compose.yml 文件中随便挑一个 restart 配置注释掉看看\nversion: \"3.9\" services: redis: image: redis:latest # restart: always privileged: false 再次运行 cargo run 就会发现报错了，报错很明显，缺少 restart 这个配置\nError: Error(\"services.redis: missing field `restart`\", line: 4, column: 5) error: process didn't exit successfully: `target\\debug\\serde_yaml_test.exe` (exit code: 1) 要解决这个问题很简单，serde 提供了一个字段属性可以快速设置这个字段的默认值，\n#[serde(default)] 如果反序列化时该值不存在，使用Default::default()生成默认值\n在 ServiceCfg.restart 中加上就可以，所以把 ServiceCfg 结构体修改成以下的样子：\n#[derive(Debug, Clone, Serialize, Deserialize)] struct ServiceCfg { image: String, #[serde(default)] restart: String, } // 再次执行 cargo run 后会得到以下输出 // 反序列化后的结构体: DockerYaml { version: \"3.9\", services: {\"nginx\": ServiceCfg { image: \"nginx:latest\", restart: \"always\" }, \"redis\": ServiceCfg { image: \"redis:latest\", restart: \"\" }} } // services name: nginx // services config: ServiceCfg { image: \"nginx:latest\", restart: \"always\" } // services name: redis // services config: ServiceCfg { image: \"redis:latest\", restart: \"\" } 自此，可选配置的默认值问题就解决了，但又有个问题，ports 和 volumes 该使用什么数据类型来承载呢，其实 yml 文件中，所有以 - 开头的，都表示同一级下有多个值，就那 redis 的 volumes 来说，他表示要映射本地多个数据卷到容器中，具体多少个？不知道，那这种结构是不是有点像可变长度的数组，在 rust 中最适合这种结构的类型是不是就是 Vec 了，基于此最终完善 ServiceCfg 结构体的内容如下：\n#[derive(Debug, Clone, Serialize, Deserialize)] struct ServiceCfg { image: String, #[serde(default)] restart: String, #[serde(default)] privileged: bool, #[serde(default)] ports: Vec, #[serde(default)] volumes: Vec, #[serde(default)] command: String, #[serde(default)] depends_on: Vec, } 现在可以随意注释掉 services 中的除 image 配置外的所有配置了，而且解析也不会报错，也有默认值了，把 networks 配置也一并实现了吧\n#[derive(Debug, Serialize, Deserialize)] struct DockerYaml { version: String, services: HashMap, #[serde(default)] networks: HashMap, } #[derive(Debug, Clone, Serialize, Deserialize)] struct ServiceCfg { image: String, #[serde(default)] restart: String, #[serde(default)] privileged: bool, #[serde(default)] ports: Vec, #[serde(default)] volumes: Vec, #[serde(default)] command: String, #[serde(default)] depends_on: Vec, } #[derive(Debug, Clone, Serialize, Deserialize)] struct NetworkCfg { #[serde(default)] driver: Option, #[serde(default)] attachable: Option, } fn main() -\u003e Result\u003c(), Box\u003e { let mut file = File::open(\"docker-compose.yml\")?; // 打开文件 let mut contents = String::new(); // 创建一个字符串 file.read_to_string(\u0026mut contents)?; // 读取文件内容到字符串缓冲区 // println!(\"读取到的 YAML 内容:\\n{}\", contents); // 打印原始的YAML字符串 // 将 YAML 字符串反序列化为 DockerYaml 结构体 let docker_yaml: DockerYaml = serde_yaml::from_str(\u0026contents)?; // 打印反序列化后的结构体 println!(\"反序列化后的结构体: {:?}\", docker_yaml); // 读取出 services let services = \u0026docker_yaml.services; for (serve, config) in services { println!(\"services name: {}\", serve); println!(\"services config: {:?}\", config); } // 读取出 networks let networks = \u0026docker_yaml.networks; for (serve, config) in networks { println!(\"networks name: {}\", serve); println!(\"networks config: {:?}\", config); } // 将数据结构序列化为 YAML 字符串 let yaml_string = serde_yaml::to_string(\u0026docker_yaml)?; println!(\"序列化为 YAML 字符串:\\n{}\", yaml_string); // 打印序列化后的 YAML 字符串 Ok(()) } 因为 networks 配置也是一个可选配置，所以在 DockerYaml 结构体中要加上 #[serde(default)]字段属性，至此，读取 yml 文件算是完成了，但看上面的 main 函数，把反序列化的结构体再转换为 yml 文件，就会有点点小问题，实际上上面代码执行完后会生成一个跟读取的 yml 文件不一样内容的 yml 字符串出来，如果期望读取的什么 yml 生成的 yml 也一模一样怎么办？\n3.序列化时剔除默认配置 需要可选字段在未设置时在反序列时有生成默认值，但在序列化时把默认值去除，可以使用 serde 的 #[serde(skip_serializing_if = \"path\")] 调用一个函数来确定是否跳过序列化该字段。给定的函数必须可以作为fn(\u0026T)-\u003ebool调用，尽管它可能是T上的泛型。例如skip_serializing_if=\"Option::is_none\"如果值是 None，那么就会跳过。\n现在来改造一下上面的 ServiceCfg ：\n#[derive(Debug, Clone, Serialize, Deserialize)] struct ServiceCfg { image: String, #[serde(skip_serializing_if = \"String::is_empty\", default)] restart: String, #[serde(skip_serializing_if = \"Option::is_none\", default)] privileged: Option, #[serde(skip_serializing_if = \"Vec::is_empty\", default)] ports: Vec, #[serde(skip_serializing_if = \"Vec::is_empty\", default)] volumes: Vec, #[serde(skip_serializing_if = \"String::is_empty\", default)] command: String, #[serde(skip_serializing_if = \"Vec::is_empty\", default)] depends_on: Vec, } 这里有个细节是 privileged 属性由原来的 bool 类型换成了 Option， 其中缘由就是 bool 类型不好做类型默认值判断， 像其他的 String，Vec，Option 都有对应的函数给 skip_serializing_if 做默认值判断，换成 Option 后，解析时如果遇到未配置时就会使用 None 代替原来的 bool 默认值，因为 Option 类型的默认值就是 None ，后面使用起来也是很方便的，实际上所有的可选字段配置都可以使用 Option 类型包起来，比如: depends_on : Option","wordCount":"3950","inLanguage":"zh","datePublished":"2024-10-23T11:14:01+08:00","dateModified":"2024-10-23T11:14:01+08:00","author":[{"@type":"Person","name":"Lorenwe"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://lorenwe.eu.org/posts/tech/rust%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%A7%A3%E6%9E%90yaml%E6%96%87%E4%BB%B6/"},"publisher":{"@type":"Organization","name":"Lorenwe Blog","logo":{"@type":"ImageObject","url":"https://lorenwe.eu.org/img/favicon.ico"}}}</script></head><body id=top><script>(function(){let e,t=new RegExp("(^| )change-themes=([^;]*)(;|$)");(e=document.cookie.match(t))||((new Date).getHours()>=19||(new Date).getHours()<6?(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark")):(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")))})(),localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lorenwe.eu.org/ accesskey=h title="Lorenwe Blog (Alt + H)"><img src=https://lorenwe.eu.org/img/kaola.png alt=logo aria-label=logo height=35>Lorenwe Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://lorenwe.eu.org/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://lorenwe.eu.org/ title="🏠 主页"><span>🏠 主页</span></a></li><li><a href=https://lorenwe.eu.org/posts title="📚 文章"><span>📚 文章</span></a></li><li><a href=https://lorenwe.eu.org/tags title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://lorenwe.eu.org/archives/ title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://lorenwe.eu.org/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li><li><a href=https://lorenwe.eu.org/links title="🤝 友链"><span>🤝 友链</span></a></li></ul></nav></header><main class="main page"><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}</style><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://lorenwe.eu.org/>🏠 主页</a>&nbsp;»&nbsp;<a href=https://lorenwe.eu.org/posts/>📚文章</a>&nbsp;»&nbsp;<a href=https://lorenwe.eu.org/posts/tech/>👨🏻‍💻 技术</a></div><h1 class=post-title>Rust如何正确解析yaml文件</h1><div class=post-meta><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}.parent-post-meta{display:flex;flex-wrap:wrap;opacity:.8}</style><span class=parent-post-meta><span id=post_meta_style_1><span class="fa fa-calendar-check-o"></span>
<span>2024-10-23
&nbsp;&nbsp;
</span></span><span id=post_meta_style_3><span class="fa fa-file-word-o"></span>
<span>3950字
&nbsp;&nbsp;
</span></span><span id=post_meta_style_4><span class="fa fa-clock-o"></span>
<span>8分钟
&nbsp;&nbsp;
</span></span><span id=post_meta_style_5><span class="fa fa-user-o"></span>
<span>Lorenwe
&nbsp;&nbsp;
</span></span><span id=post_meta_style_6><span class="fa fa-tags" style=opacity:.8></span>
<span><span class=post-tags-meta></span></span></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e7%ae%80%e4%bb%8b aria-label=一、简介>一、简介</a></li><li><a href=#%e4%ba%8c%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af aria-label=二、使用场景>二、使用场景</a></li><li><a href=#%e4%b8%89%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8 aria-label=三、基本使用>三、基本使用</a><ul><li><a href=#1%e8%af%bb%e5%8f%96%e5%92%8c%e8%a7%a3%e6%9e%90-yaml-%e6%96%87%e4%bb%b6 aria-label="1、读取和解析 YAML 文件">1、读取和解析 YAML 文件</a></li><li><a href=#2%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%ba-yaml aria-label="2、序列化数据结构为 YAML">2、序列化数据结构为 YAML</a></li><li><a href=#3%e4%bd%bf%e7%94%a8%e8%87%aa%e5%ae%9a%e4%b9%89%e7%bb%93%e6%9e%84%e4%bd%93%e8%bf%9b%e8%a1%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96 aria-label=3、使用自定义结构体进行反序列化>3、使用自定义结构体进行反序列化</a></li><li><a href=#4%e4%bb%8e%e6%96%87%e4%bb%b6%e6%b5%81%e4%b8%ad%e7%9b%b4%e6%8e%a5%e8%a7%a3%e6%9e%90 aria-label=4、从文件流中直接解析>4、从文件流中直接解析</a></li></ul></li><li><a href=#%e5%9b%9b%e5%a4%8d%e6%9d%82-yaml-%e6%96%87%e4%bb%b6%e8%a7%a3%e6%9e%90 aria-label="四、复杂 YAML 文件解析">四、复杂 YAML 文件解析</a><ul><li><a href=#1%e5%9b%ba%e5%ae%9a%e5%ad%97%e6%ae%b5%e8%a7%a3%e6%9e%90 aria-label=1.固定字段解析>1.固定字段解析</a></li><li><a href=#2%e5%8a%a8%e6%80%81%e5%ad%97%e6%ae%b5%e8%a7%a3%e6%9e%90 aria-label=2.动态字段解析>2.动态字段解析</a></li><li><a href=#3%e5%ba%8f%e5%88%97%e5%8c%96%e6%97%b6%e5%89%94%e9%99%a4%e9%bb%98%e8%ae%a4%e9%85%8d%e7%bd%ae aria-label=3.序列化时剔除默认配置>3.序列化时剔除默认配置</a></li></ul></li><li><a href=#%e4%ba%94%e6%80%bb%e7%bb%93 aria-label=五、总结>五、总结</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{elements&&(activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=一简介>一、简介<a hidden class=anchor aria-hidden=true href=#一简介>#</a></h3><p>serde_yaml 是 Rust 语言中一个用于序列化和反序列化 YAML 数据的库。它以其高性能和灵活性而广受欢迎，特别适用于需要处理 YAML 配置文件的项目。在这篇博客中，我们将探讨 serde_yaml 的基本用法，并提供一些实用的示例代码。</p><h3 id=二使用场景>二、使用场景<a hidden class=anchor aria-hidden=true href=#二使用场景>#</a></h3><p>serde_yaml 常用于以下场景：</p><ul><li>配置管理：许多应用程序使用 YAML 文件来存储配置参数，serde_yaml 可以轻松解析这些文件。</li><li>数据交换：在系统之间传递数据时，YAML 格式因其可读性而常被选用。</li><li>文档生成：一些工具使用 YAML 来描述文档结构，serde_yaml 可以帮助生成和解析这些文档。</li></ul><h3 id=三基本使用>三、基本使用<a hidden class=anchor aria-hidden=true href=#三基本使用>#</a></h3><p>开始使用 serde_yaml 之前，先创建一个 serde_yaml_test 项目文件夹，在文件夹中使用 <code>cargo init</code> 初始化 rust 项目，然后在项目的 Cargo.toml 文件中添加依赖：</p><pre><code class=language-toml>serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_yaml = &quot;0.9.34&quot;
</code></pre><p>要使用最新版本的 serde 的话可以使用命令行来添加依赖，如：</p><pre><code class=language-bash> cargo add serde --features=&quot;derive&quot;
 cargo add serde_yaml
</code></pre><p>依赖的包都准备完成后，就来看看几个示例，演示如何读取、解析和生成 YAML 文件。</p><h4 id=1读取和解析-yaml-文件>1、读取和解析 YAML 文件<a hidden class=anchor aria-hidden=true href=#1读取和解析-yaml-文件>#</a></h4><p>以下是一个基本示例，展示了如何使用 serde_yaml 读取和解析一个名为 以下是一个基本示例，展示了如何使用 serde_yaml 读取和解析一个名为 <code>hello.yml</code> 的文件： 的文件：</p><pre><code class=language-bash># 在项目根目录创建一个 hello.yml 文件
touch hello.yml
# 此时目录结构为
#|-serde_yaml_test
#   |--src
#   |--target
#   |--.gitignore
#   |--Cargo.lock
#   |--Cargo.toml
#   |--hello.yml
</code></pre><pre><code class=language-rust>use std::collections::BTreeMap;
use std::fs::File;
use std::io::Read;
use serde_yaml;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut file = File::open(&quot;hello.yml&quot;)?; // 打开文件 hello.yml
    let mut contents = String::new(); // 创建一个字符串
    file.read_to_string(&amp;mut contents)?; // 读取文件内容到字符串缓冲区
    println!(&quot;YAML file contents:\n{}&quot;, contents); // 打印原始的YAML字符串
    // 将YAML字符串反序列化为BTreeMap
    let deserialized_map: BTreeMap&lt;String, serde_yaml::Value&gt; = serde_yaml::from_str(&amp;contents)?;
    println!(&quot;Deserialized map: {:#?}&quot;, deserialized_map);  // 打印反序列化后的数据结构
    if let Some(name) = deserialized_map.get(&quot;name&quot;).and_then(|v| v.as_str()) {
        println!(&quot;name: {}&quot;, name); // 打印 name
    } else {
        println!(&quot;The key 'name' was not found or is not a string.&quot;);
    }
    Ok(())
}
// 输出结果：
//    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.03s
//     Running `target\debug\serde_yaml_test.exe`
// YAML file contents:
// name: data
// Deserialized map: {
//     &quot;name&quot;: String(&quot;data&quot;),
// }
// name: data

</code></pre><h4 id=2序列化数据结构为-yaml>2、序列化数据结构为 YAML<a hidden class=anchor aria-hidden=true href=#2序列化数据结构为-yaml>#</a></h4><p>示例展示了如何将一个 Rust 数据结构序列化为 YAML 格式的字符串：</p><pre><code class=language-rust>use std::collections::BTreeMap;
use serde_yaml;
fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // 创建一个 BTreeMap 数据结构
    let mut data = BTreeMap::new();
    data.insert(&quot;name&quot;.to_string(), serde_yaml::Value::String(&quot;Alice&quot;.to_string()));
    data.insert(&quot;age&quot;.to_string(), serde_yaml::Value::Number(serde_yaml::Number::from(30)));
    // 将数据结构序列化为 YAML 字符串
    let yaml_string = serde_yaml::to_string(&amp;data)?;
    // 打印序列化后的 YAML 字符串
    println!(&quot;Serialized YAML:\n{}&quot;, yaml_string);
    Ok(())
}
</code></pre><h4 id=3使用自定义结构体进行反序列化>3、使用自定义结构体进行反序列化<a hidden class=anchor aria-hidden=true href=#3使用自定义结构体进行反序列化>#</a></h4><p>使用自定义结构体来解析 YAML 数据会更加方便和直观。以下示例展示了如何定义一个结构体并解析 YAML 数据：</p><pre><code class=language-rust>use serde::{Deserialize, Serialize};
use serde_yaml;

#[derive(Debug, Serialize, Deserialize)]
struct Person {
    name: String,
    age: u8,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // 定义一个 YAML 字符串
    let yaml_str = &quot;
name: Bob
age: 25
&quot;;
    // 将 YAML 字符串反序列化为 Person 结构体
    let person: Person = serde_yaml::from_str(yaml_str)?;
    // 打印反序列化后的结构体
    println!(&quot;Deserialized person: {:?}&quot;, person);
    Ok(())
}
</code></pre><h4 id=4从文件流中直接解析>4、从文件流中直接解析<a hidden class=anchor aria-hidden=true href=#4从文件流中直接解析>#</a></h4><p>有时，为了优化内存使用，可以直接从文件流中进行解析：</p><pre><code class=language-rust>use serde::{Deserialize, Serialize};
use std::fs::File;

#[derive(Debug, Serialize, Deserialize)]
struct Config {
    database_url: String,
    port: u16,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // 打开配置文件
    let file = File::open(&quot;config.yml&quot;)?;
    // 从文件流中直接反序列化
    let config: Config = serde_yaml::from_reader(file)?;
    // 打印反序列化后的配置
    println!(&quot;Config: {:?}&quot;, config);
    Ok(())
}
</code></pre><h3 id=四复杂-yaml-文件解析>四、复杂 YAML 文件解析<a hidden class=anchor aria-hidden=true href=#四复杂-yaml-文件解析>#</a></h3><p>基于以上案例，来尝试解析一个复杂的 yaml 文件，既然要复杂，那就尝试解析一下 <code>docker-compose.yml</code>文件吧！先来准备一个 yaml 文件，放在项目根目录下，如下：</p><pre><code class=language-yaml>version: &quot;3.9&quot;
services:
  redis:
    image: redis:latest
    restart: always
    privileged: true
    ports:
      - 6379:6379
    volumes:
      - ./data/redis/data:/data
      - ./redis/etc:/usr/local/etc/redis
    command: redis-server /usr/local/etc/redis/redis.conf
  nginx:
    image: nginx:latest
    restart: always
    privileged: true
    volumes:
      - ./nginx/etc/nginx:/etc/nginx
      - ./var/www:/var/www/html
    ports:
      - &quot;80:80&quot;
      - &quot;443:443&quot;
    depends_on:
      - redis
networks:
  mynet1:
    driver: overlay
    attachable: false
</code></pre><p>再写代码之前，先把 rust 引入的包先贴出来，后面贴代码时可以少写一点啰嗦代码，只关注核心逻辑，看起来更清晰易懂，这是整个项目所依赖的包，也没有很多</p><pre><code class=language-rust>use std::collections::HashMap;
use std::fmt::{Debug, Display};
use std::fs::File;
use std::io::Read;
use serde::{Deserialize, Serialize};
</code></pre><h4 id=1固定字段解析>1.固定字段解析<a hidden class=anchor aria-hidden=true href=#1固定字段解析>#</a></h4><p>整个 yml 文件看下来，并没有很多，但算是一个比较全面的 docker-compose 配置文件了，虽然没有用到所有的配置字段，触类旁通，再多的配置字段都能轻车熟路的解析吧，先一级一级的看，一级有 <code>version</code> <code>services</code> <code>networks</code>，通过以上，就可以定义出需要的结构体了：</p><pre><code class=language-rust>#[derive(Debug, Serialize, Deserialize)]
struct DockerYaml {
    version: String,
    services: HashMap&lt;String, ServiceCfg&gt;,
}
</code></pre><p>这里的 services 的类型用的是 HashMap，因为 services 名称是一个变量，而且数量不固定，比如还可以增加 mysql 服务，所以 services 是一个动态，services 里面又引入了 ServiceCfg 类型，现在继续看 services 下一级的配置字段，其中 image 是必须要存在的配置，那 ServiceCfg 结构体可以定义成：</p><pre><code class=language-rust>#[derive(Debug, Clone, Serialize, Deserialize)]
struct ServiceCfg {
    image: String,
}
</code></pre><p>好了，就这么简单，先写个 main 函数把代码跑起来看看吧！</p><pre><code class=language-rust>fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut file = File::open(&quot;docker-compose.yml&quot;)?; // 打开文件
    let mut contents = String::new(); // 创建一个字符串
    file.read_to_string(&amp;mut contents)?; // 读取文件内容到字符串缓冲区
    // println!(&quot;读取到的 YAML 内容:\n{}&quot;, contents); // 打印原始的YAML字符串
    // 将 YAML 字符串反序列化为 DockerYaml 结构体
    let docker_yaml: DockerYaml = serde_yaml::from_str(&amp;contents)?;
    // 打印反序列化后的结构体
    println!(&quot;反序列化后的结构体: {:?}&quot;, docker_yaml);
    // 读取出 services
    let services = &amp;docker_yaml.services;
    for (serve, config) in services {
        println!(&quot;services name: {}&quot;, serve);
        println!(&quot;services config: {:?}&quot;, config);
    }
    Ok(())
}
// 打印的内容：
// 反序列化后的结构体: DockerYaml { version: &quot;3.9&quot;, services: {&quot;nginx&quot;: ServiceCfg { image: &quot;nginx:latest&quot; }, &quot;redis&quot;: ServiceCfg { image: &quot;redis:latest&quot; }} }
// services name: nginx
// services config: ServiceCfg { image: &quot;nginx:latest&quot; }
// services name: redis
// services config: ServiceCfg { image: &quot;redis:latest&quot; }
</code></pre><p>正常打印了，现在可以完善 ServiceCfg 这个结构体了</p><h4 id=2动态字段解析>2.动态字段解析<a hidden class=anchor aria-hidden=true href=#2动态字段解析>#</a></h4><p>docker-compose 配置的 services 中，大部分配置都可选的，如果不配置，就会有个默认值，先不关心这个默认值是什么，但起码要实现一个不配置会有默认值的功能，带着疑问，先去写一下代码，</p><p>把 ServiceCfg 结构体修改成以下的样子：</p><pre><code class=language-rust>#[derive(Debug, Clone, Serialize, Deserialize)]
struct ServiceCfg {
    image: String,
    restart: String,
}
</code></pre><p>只是添加了一个 restart 配置项，main 函数不变，cargo run 一下发现正常打印了如下：</p><pre><code class=language-bash>反序列化后的结构体: DockerYaml { version: &quot;3.9&quot;, services: {&quot;nginx&quot;: ServiceCfg { image: &quot;nginx:latest&quot;, restart: &quot;always&quot; }, &quot;redis&quot;: ServiceCfg { image: &quot;redis:latest&quot;, restart: &quot;always&quot; }} }
services name: nginx
services config: ServiceCfg { image: &quot;nginx:latest&quot;, restart: &quot;always&quot; }
services name: redis
services config: ServiceCfg { image: &quot;redis:latest&quot;, restart: &quot;always&quot; }
</code></pre><p>restart 配置项正常读取到了，好像一切都很完美，但 restart 配置是个可选配置，那在 <code>docker-compose.yml</code>  文件中随便挑一个 restart 配置注释掉看看</p><pre><code class=language-yml>version: &quot;3.9&quot;
services:
  redis:
    image: redis:latest
    # restart: always
    privileged: false
</code></pre><p>再次运行 cargo run 就会发现报错了，报错很明显，缺少 restart 这个配置</p><pre><code class=language-bash>Error: Error(&quot;services.redis: missing field `restart`&quot;, line: 4, column: 5)
error: process didn't exit successfully: `target\debug\serde_yaml_test.exe` (exit code: 1)
</code></pre><p>要解决这个问题很简单，serde 提供了一个字段属性可以快速设置这个字段的默认值，</p><p><code>#[serde(default)]</code> 如果反序列化时该值不存在，使用<code>Default::default()</code>生成默认值</p><p>在 ServiceCfg.restart 中加上就可以，所以把 ServiceCfg 结构体修改成以下的样子：</p><pre><code class=language-rust>#[derive(Debug, Clone, Serialize, Deserialize)]
struct ServiceCfg {
    image: String,
    #[serde(default)]
    restart: String,
}
// 再次执行 cargo run 后会得到以下输出
// 反序列化后的结构体: DockerYaml { version: &quot;3.9&quot;, services: {&quot;nginx&quot;: ServiceCfg { image: &quot;nginx:latest&quot;, restart: &quot;always&quot; }, &quot;redis&quot;: ServiceCfg { image: &quot;redis:latest&quot;, restart: &quot;&quot; }} }
// services name: nginx
// services config: ServiceCfg { image: &quot;nginx:latest&quot;, restart: &quot;always&quot; }
// services name: redis
// services config: ServiceCfg { image: &quot;redis:latest&quot;, restart: &quot;&quot; }
</code></pre><p>自此，可选配置的默认值问题就解决了，但又有个问题，ports 和 volumes 该使用什么数据类型来承载呢，其实 yml 文件中，所有以 - 开头的，都表示同一级下有多个值，就那 redis 的 volumes 来说，他表示要映射本地多个数据卷到容器中，具体多少个？不知道，那这种结构是不是有点像可变长度的数组，在 rust 中最适合这种结构的类型是不是就是 Vec 了，基于此最终完善 ServiceCfg 结构体的内容如下：</p><pre><code class=language-rust>#[derive(Debug, Clone, Serialize, Deserialize)]
struct ServiceCfg {
    image: String,
    #[serde(default)]
    restart: String,
    #[serde(default)]
    privileged: bool,
    #[serde(default)]
    ports: Vec&lt;String&gt;,
    #[serde(default)]
    volumes: Vec&lt;String&gt;,
    #[serde(default)]
    command: String,
    #[serde(default)]
    depends_on: Vec&lt;String&gt;,
}
</code></pre><p>现在可以随意注释掉 services 中的除 image 配置外的所有配置了，而且解析也不会报错，也有默认值了，把 networks 配置也一并实现了吧</p><pre><code class=language-rust>#[derive(Debug, Serialize, Deserialize)]
struct DockerYaml {
    version: String,
    services: HashMap&lt;String, ServiceCfg&gt;,
    #[serde(default)]
    networks: HashMap&lt;String, NetworkCfg&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct ServiceCfg {
    image: String,
    #[serde(default)]
    restart: String,
    #[serde(default)]
    privileged: bool,
    #[serde(default)]
    ports: Vec&lt;String&gt;,
    #[serde(default)]
    volumes: Vec&lt;String&gt;,
    #[serde(default)]
    command: String,
    #[serde(default)]
    depends_on: Vec&lt;String&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct NetworkCfg {
    #[serde(default)]
    driver: Option&lt;String&gt;,
    #[serde(default)]
    attachable: Option&lt;bool&gt;,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut file = File::open(&quot;docker-compose.yml&quot;)?; // 打开文件
    let mut contents = String::new(); // 创建一个字符串
    file.read_to_string(&amp;mut contents)?; // 读取文件内容到字符串缓冲区
    // println!(&quot;读取到的 YAML 内容:\n{}&quot;, contents); // 打印原始的YAML字符串
    // 将 YAML 字符串反序列化为 DockerYaml 结构体
    let docker_yaml: DockerYaml = serde_yaml::from_str(&amp;contents)?;
    // 打印反序列化后的结构体
    println!(&quot;反序列化后的结构体: {:?}&quot;, docker_yaml);
    // 读取出 services
    let services = &amp;docker_yaml.services;
    for (serve, config) in services {
        println!(&quot;services name: {}&quot;, serve);
        println!(&quot;services config: {:?}&quot;, config);
    }
    // 读取出 networks
    let networks = &amp;docker_yaml.networks;
    for (serve, config) in networks {
        println!(&quot;networks name: {}&quot;, serve);
        println!(&quot;networks config: {:?}&quot;, config);
    }
    // 将数据结构序列化为 YAML 字符串
    let yaml_string = serde_yaml::to_string(&amp;docker_yaml)?;
    println!(&quot;序列化为 YAML 字符串:\n{}&quot;, yaml_string); // 打印序列化后的 YAML 字符串
    Ok(())
}
</code></pre><p>因为 networks 配置也是一个可选配置，所以在 DockerYaml 结构体中要加上 <code>#[serde(default)]</code>字段属性，至此，读取 yml 文件算是完成了，但看上面的 main 函数，把反序列化的结构体再转换为 yml 文件，就会有点点小问题，实际上上面代码执行完后会生成一个跟读取的 yml 文件不一样内容的 yml 字符串出来，如果期望读取的什么 yml 生成的 yml 也一模一样怎么办？</p><h4 id=3序列化时剔除默认配置>3.序列化时剔除默认配置<a hidden class=anchor aria-hidden=true href=#3序列化时剔除默认配置>#</a></h4><p>需要可选字段在未设置时在反序列时有生成默认值，但在序列化时把默认值去除，可以使用 serde 的 <code>#[serde(skip_serializing_if = "path")]</code> 调用一个函数来确定是否跳过序列化该字段。给定的函数必须可以作为<code>fn(&amp;T)->bool</code>调用，尽管它可能是<code>T</code>上的泛型。例如<code>skip_serializing_if="Option::is_none"</code>如果值是 None，那么就会跳过。</p><p>现在来改造一下上面的 ServiceCfg ：</p><pre><code class=language-rust>#[derive(Debug, Clone, Serialize, Deserialize)]
struct ServiceCfg {
    image: String,
    #[serde(skip_serializing_if = &quot;String::is_empty&quot;, default)]
    restart: String,
    #[serde(skip_serializing_if = &quot;Option::is_none&quot;, default)]
    privileged: Option&lt;bool&gt;,
    #[serde(skip_serializing_if = &quot;Vec::is_empty&quot;, default)]
    ports: Vec&lt;String&gt;,
    #[serde(skip_serializing_if = &quot;Vec::is_empty&quot;, default)]
    volumes: Vec&lt;String&gt;,
    #[serde(skip_serializing_if = &quot;String::is_empty&quot;, default)]
    command: String,
    #[serde(skip_serializing_if = &quot;Vec::is_empty&quot;, default)]
    depends_on: Vec&lt;String&gt;,
}
</code></pre><p>这里有个细节是 privileged 属性由原来的 <code>bool</code> 类型换成了 <code>Option&lt;bool></code>， 其中缘由就是 bool 类型不好做类型默认值判断， 像其他的 String，Vec，Option 都有对应的函数给 <code>skip_serializing_if</code> 做默认值判断，换成 Option 后，解析时如果遇到未配置时就会使用 None 代替原来的 bool 默认值，因为 Option 类型的默认值就是 None ，后面使用起来也是很方便的，实际上所有的可选字段配置都可以使用 Option 类型包起来，比如: <code>depends_on : Option&lt;Vec&lt;String>></code>，只不过这样写后默认值就不是空的 Vec 了，而是 None，而值存在时就是 Some(Vec[]) 了。</p><p>现在还剩一个问题，就是 networks 如果没有配置，但生成的 yml 也会默认带上 networks: {}，这个可以使用 HashMap::is_empty 来判断，</p><pre><code class=language-rust>#[derive(Debug, Serialize, Deserialize)]
struct DockerYaml {
    version: String,
    services: HashMap&lt;String, ServiceCfg&gt;,
    #[serde(skip_serializing_if = &quot;HashMap::is_empty&quot;, default)]
    networks: HashMap&lt;String, NetworkCfg&gt;,
}
</code></pre><p>那如果是自己定义的类型呢，难道要给自定义类型增加一个判断是否为空的方法吗？可以，但没必要，除非其他逻辑有用到，可以定义一个函数来判断类型是否为空，比如：</p><pre><code class=language-rust>#[derive(Debug, Serialize, Deserialize)]
struct DockerYaml {
    version: String,
    services: HashMap&lt;String, ServiceCfg&gt;,
    #[serde(skip_serializing_if = &quot;is_default&quot;, default)]
    networks: HashMap&lt;String, NetworkCfg&gt;,
}
// 调用这个函数来确定是否跳过序列化该字段
fn is_default&lt;T: Default + PartialEq&gt;(v: &amp;T) -&gt; bool {
    v == &amp;T::default()
}
// 因为泛型 T 在函数中用到比较运算，所以要给泛型添加 PartialEq 约束，
// 用于判断是否是默认值，所以 T 要有 default 方法，故也要加上 Default 约束
// 其中 T 表示 HashMap，如果 HashMap 的泛型约束有 PartialEq， 那就表示 HashMap 里面
// 的类型也同样具有相应的约束，所以 NetworkCfg 也要实现 PartialEq trait,
// 而 Default trait 是默认实现的，因为 NetworkCfg  里所有的成员都实现了 Default trait
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)] // 这行可以省略 Default
struct NetworkCfg {
    #[serde(default)]
    driver: Option&lt;String&gt;,
    #[serde(default)]
    attachable: Option&lt;bool&gt;,
}
</code></pre><h3 id=五总结>五、总结<a hidden class=anchor aria-hidden=true href=#五总结>#</a></h3><p>至此，解析 yml 文件算是大功告成了，当然这里只是介绍一小部分 serde 字段属性，但也可以应付大部分场景了，其他的比如字段别名，序列化时处理逻辑，反序列化时处理逻辑，就留在以后去探索吧。</p></div><div class=post-reward><div style=padding:0;margin:0;width:100%;font-size:16px;text-align:center><div id=QR style=opacity:0><div id=wechat style=display:inline-block><a class=fancybox rel=group><img id=wechat_qr src=https://lorenwe.eu.org/img/wechat_pay.png alt=wechat_pay></a><p>微信</p></div><div id=alipay style=display:inline-block><a class=fancybox rel=group><img id=alipay_qr src=https://lorenwe.eu.org/img/alipay.png alt=alipay></a><p>支付宝</p></div></div><button id=rewardButton onclick='var qr=document.getElementById("QR");qr.style.opacity==="0"?qr.style.opacity="1":qr.style.opacity="0"'>
<span>🧧 鼓励</span></button></div></div><footer class=post-footer><nav class=paginav><a class=next href=https://lorenwe.eu.org/posts/tech/rust%E4%B8%AD%E7%9A%84sized/><span class=title>下一页 »</span><br><span>Rust 中的 Sized</span></a></nav></footer></div><div id=giscus-comment></div><script>function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");if(!t||!t.contentWindow)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}function createGusicScript(){const t=document.querySelector("#giscus-comment"),n=localStorage.getItem("pref-theme");let e=document.createElement("script");e.src="https://giscus.app/client.js",e.setAttribute("data-repo","lorenwe/lorenwe.github.io"),e.setAttribute("data-repo-id","MDEwOlJlcG9zaXRvcnk3NDY0NzM4MQ=="),e.setAttribute("data-category","Announcements"),e.setAttribute("data-category-id","DIC_kwDOBHMHVc4CizTN"),e.setAttribute("data-mapping","title"),e.setAttribute("data-strict","0"),e.setAttribute("data-reactions-enabled","1"),e.setAttribute("data-emit-metadata","0"),e.setAttribute("data-input-position","bottom"),e.setAttribute("data-theme",n),e.setAttribute("data-lang","zh-CN"),e.setAttribute("data-loading","lazy"),e.setAttribute("crossorigin","anonymous"),e.async=!0,t&&t.appendChild(e)}createGusicScript()</script></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>200||document.documentElement.scrollTop>200?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{(function(){document.cookie="change-themes="+escape("false")})(),document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),sendMessage({setConfig:{theme:"light"}})):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),sendMessage({setConfig:{theme:"dark"}}))})</script><script>document.body.addEventListener("copy",function(e){if(window.getSelection().toString()&&window.getSelection().toString().length>50){let t=e.clipboardData||window.clipboardData;if(t){e.preventDefault();let n=window.getSelection().toString()+`\r

————————————————\r
版权声明：本文为「Lorenwe Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\r
原文链接：`+location.href,s=window.getSelection().toString()+`\r

————————————————\r
版权声明：本文为「Lorenwe Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\r
原文链接：`+location.href;t.setData("text/html",n),t.setData("text/plain",s)}}})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="复制";function i(){t.innerText="已复制！",setTimeout(()=>{t.innerText="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){let t=e.textContent+`\r
————————————————\r
版权声明：本文为「Lorenwe Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\r
原文链接：`+location.href;navigator.clipboard.writeText(t),i();return}const n=document.createRange();n.selectNodeContents(e);const s=window.getSelection();s.removeAllRanges(),s.addRange(n);try{document.execCommand("copy"),i()}catch{}s.removeRange(n)});let l=e.className.replaceAll("language-",""),n=document.createElement("div"),a=document.createElement("div"),r=document.createElement("div"),c=document.createElement("div"),o=document.createElement("div");o.innerText=l,n.setAttribute("class","mac-tool"),a.setAttribute("class","mac bb1"),r.setAttribute("class","mac bb2"),c.setAttribute("class","mac bb3"),o.setAttribute("class","language-type"),n.appendChild(a),n.appendChild(r),n.appendChild(c),n.appendChild(o),s.classList.contains("highlight")?(s.appendChild(t),s.appendChild(n)):s.parentNode.firstChild==s||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?(e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t),s.appendChild(n)):(e.parentNode.appendChild(t),s.appendChild(n)))})</script></body></html>