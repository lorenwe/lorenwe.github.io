[{"content":"New_life\n","permalink":"https://lorenwe.eu.org/posts/life/new_life/","summary":"\u003cp\u003eNew_life\u003c/p\u003e","title":"New_life"},{"content":"创建代码仓库 首先创建 GitHub Pages 站点。该仓库可见性必须是 Public。\n另外创建一个仓库用来存放 Hugo 的源文件，名称随意，这里我的仓库名叫 blogs。建议将仓库可见性设置成 Private 以保护好文章 .md 文件。\n创建完毕后账户下将存在以下两个代码仓库：\n公有仓库：\nhttps://github.com/lorenwe/lorenwe.github.io\n私有仓库：\nhttps://github.com/lorenwe/blogs\n创建 Workflow 配置 在 blogs 仓库下新建 .github/workflows/deploy.yml 文件。内容如下：\nname: deploy on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Check out source uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; extended: true # 设置是否需要 extended 版本 - name: Fetch Hugo Themes # Fetch Hugo themes run: git submodule update --init --recursive - name: Build run: hugo --minify - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.DEPLOY_TOKEN }} # 另外还支持 github_token 和 personal_token external_repository: lorenwe/lorenwe.github.io # 修改为你的 GitHub Pages 仓库 publish_branch: main publish_dir: ./public keep_files: false cname: lorenwe.eu.org # 如果使用自定义域名，还需要添加下面一行配置 设置 SSH Key GitHub Pages action 支持三种身份验证方式：\ndeploy_key github_token personal_token 此处使用 deploy_key 方式。\n执行命令创建 SSH Key：ssh-keygen -t rsa -b 4096 -C \u0026quot;$(git config user.email)\u0026quot; -f gh-pages -N \u0026quot;\u0026quot;\nAdmin@DESKTOP-0O5ASOH MINGW64 ~/Desktop/blogs (main) $ ssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f gh-pages -N \u0026#34;\u0026#34; Generating public/private rsa key pair. Your identification has been saved in gh-pages Your public key has been saved in gh-pages.pub The key fingerprint is: SHA256:hXyduwgFN52vCsct9UUPVeXOiBZ+SZAcc26/KgL9Om0 lorenwe@163.com The key\u0026#39;s randomart image is: +---[RSA 4096]----+ | . oo++..*| | . + o=*...| | o + +.+oo| | + ..*.*o| | S. o=o+.+| | ..o+ooo. .| | .o+o. . | | o.E . | | .= .. | +----[SHA256]-----+ 该命令会在当前命令行所在目录下生成两个密钥对文件 gh-pages 和 gh-pages.pub, 如果在 Windows 系统下运行该命令，要将命令中的 $(git config user.email) 替换成你的邮箱地址。\n先为GitHub Pages 站点仓库设置公钥，访问如下地址设置 Public key：\nhttps://github.com/lorenwe/lorenwe.github.io/settings/keys/new\n表单中的 Title 随意填写，将刚才生成的 gh-pages.pub 文件内容填入 Key 中，勾选 Allow write access，点击 Add key 按钮保存。如图：\n添加完成后的结果：\n再为文章源码仓库设置私钥，访问如下地址设置 Private key：\nhttps://github.com/lorenwe/blogs/settings/secrets/actions/new\n表单中的 Name 填入 DEPLOY_TOKEN，将刚才生成的 gh-pages 文件内容填入 Secret 中，点击 Add secret 按钮保存。\n添加完成后的结果：\n执行 GitHub Actions 将 blogs 仓库的代码提交并推送到 GitHub，会自动触发 GitHub Actions 执行。可以访问如下网址来查看 Workflows 是否执行成功：\nhttps://github.com/lorenwe/blogs/actions\n等待 workflow 执行完毕，静态站点就算是发布成功了。\n注：文章内所有 GitHub 链接都要替换成自己的仓库链接，例如：\nhttps://github.com/\u0026lt;YourName\u0026gt;/\u0026lt;YourName\u0026gt;.github.io\nhttps://github.com/\u0026lt;YourName\u0026gt;/blogs\n","permalink":"https://lorenwe.eu.org/posts/tech/%E4%BD%BF%E7%94%A8githubactions%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E7%AB%99%E7%82%B9/","summary":"\u003ch3 id=\"创建代码仓库\"\u003e创建代码仓库\u003c/h3\u003e\n\u003cp\u003e首先创建 GitHub Pages 站点。该仓库可见性必须是 Public。\u003c/p\u003e\n\u003cp\u003e另外创建一个仓库用来存放 Hugo 的源文件，名称随意，这里我的仓库名叫 blogs。建议将仓库可见性设置成 Private 以保护好文章 .md 文件。\u003c/p\u003e\n\u003cp\u003e创建完毕后账户下将存在以下两个代码仓库：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e公有仓库：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehttps://github.com/lorenwe/lorenwe.github.io\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e私有仓库：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehttps://github.com/lorenwe/blogs\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"创建-workflow-配置\"\u003e创建 Workflow 配置\u003c/h3\u003e\n\u003cp\u003e在 blogs 仓库下新建 .github/workflows/deploy.yml 文件。内容如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-yml\" data-lang=\"yml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003edeploy\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eon\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003epush\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003ebranches\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      - \u003cspan style=\"color:#ae81ff\"\u003emain\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003ejobs\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003edeploy\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003eruns-on\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eubuntu-latest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003esteps\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eCheck out source\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003euses\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eactions/checkout@v2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003ewith\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#f92672\"\u003esubmodules\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#f92672\"\u003efetch-depth\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eSetup hugo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003euses\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003epeaceiris/actions-hugo@v2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003ewith\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#f92672\"\u003ehugo-version\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;latest\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#f92672\"\u003eextended\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 设置是否需要 extended 版本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eFetch Hugo Themes \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# Fetch Hugo themes\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003erun\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003egit submodule update --init --recursive\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eBuild\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003erun\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003ehugo --minify\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eDeploy to GitHub Pages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003euses\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003epeaceiris/actions-gh-pages@v3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003ewith\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#f92672\"\u003edeploy_key\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e${{ secrets.DEPLOY_TOKEN }}\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 另外还支持 github_token 和 personal_token\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#f92672\"\u003eexternal_repository\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003elorenwe/lorenwe.github.io\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 修改为你的 GitHub Pages 仓库\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#f92672\"\u003epublish_branch\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emain\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#f92672\"\u003epublish_dir\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e./public\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#f92672\"\u003ekeep_files\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#f92672\"\u003ecname\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003elorenwe.eu.org\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 如果使用自定义域名，还需要添加下面一行配置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"设置-ssh-key\"\u003e设置 SSH Key\u003c/h3\u003e\n\u003cp\u003eGitHub Pages action 支持三种身份验证方式：\u003c/p\u003e","title":"使用 GitHub Actions 自动部署 Hugo 站点"},{"content":"在 GitHub 上可以找到本教程的源码。\n衡量成功的标准 确保我们对代码有改进的唯一方法是测试一个不好的情况，然后将我们修复之后的测量与另一个进行比较。换句话说，除非我们知道“解决方案”对我们有多大的帮助（如果有的话），否则我们不知道它是否真的是一个解决方案。\n这里有两个我们可以关系的衡量标准。首先是CPU使用率。我们要处理的进程有多快或多慢？第二是内存使用情况。脚本执行时需要多少内存？这两个通常是成反比的 - 这意味着我们可以以CPU使用率为代价来降低内存使用，反之亦然。\n在一个异步执行模型（如多进程或多线程的PHP应用程序）中，CPU和内存的使用率是很重要的考量因素。在传统的PHP架构中，当任何一个值达到服务器的极限时，这些通常都会成为问题。\n测量PHP内的CPU使用率是不切实际的。如果这是你要关注的领域，请考虑在Ubuntu或MacOS上使用类似top的工具。对于Windows，请考虑使用Linux子系统，以便在Ubuntu中使用top。\n为了本教程的目的，我们将测量内存使用情况。我们将看看在“传统”的脚本中使用了多少内存。我们将执行一些优化策略并对其进行度量。最后，我希望你能够做出一个有经验的选择。 我们查看内存使用多少的方法是：\n// formatBytes is taken from the php.net documentation memory_get_peak_usage(); function formatBytes($bytes, $precision = 2) { $units = array(\u0026#34;b\u0026#34;, \u0026#34;kb\u0026#34;, \u0026#34;mb\u0026#34;, \u0026#34;gb\u0026#34;, \u0026#34;tb\u0026#34;); $bytes = max($bytes, 0); $pow = floor(($bytes ? log($bytes) : 0) / log(1024)); $pow = min($pow, count($units) - 1); $bytes /= (1 \u0026lt;\u0026lt; (10 * $pow)); return round($bytes, $precision) . \u0026#34; \u0026#34; . $units[$pow]; } 我们将在脚本的最后使用这些函数，以便我们能够看到哪个脚本一次使用最大的内存。\n我们的选择是什么？ 这里有很多方法可以有效地读取文件。但是也有两种我们可能使用它们的情况。我们想要同时读取和处理所有数据，输出处理过的数据或根据我们所读取的内容执行其他操作。我们也可能想要转换一个数据流，而不需要真正访问的数据。 让我们设想一下，对于第一种情况，我们希望读取一个文件，并且每10,000行创建一个独立排队的处理作业。我们需要在内存中保留至少10000行，并将它们传递给排队的工作管理器（无论采取何种形式）。 对于第二种情况，我们假设我们想要压缩一个特别大的API响应的内容。我们不在乎它的内容是什么，但我们需要确保它是以压缩形式备份的。 在这两种情况下，如果我们需要读取大文件，首先，我们需要知道数据是什么。第二，我们并不在乎数据是什么。让我们来探索这些选择吧\u0026hellip;\n逐行读取文件 有许多操作文件的函数，我们把部分结合到一个简单的文件阅读器中(封装为一个方法)：\n// from memory.php function formatBytes($bytes, $precision = 2) { $units = array(\u0026#34;b\u0026#34;, \u0026#34;kb\u0026#34;, \u0026#34;mb\u0026#34;, \u0026#34;gb\u0026#34;, \u0026#34;tb\u0026#34;); $bytes = max($bytes, 0); $pow = floor(($bytes ? log($bytes) : 0) / log(1024)); $pow = min($pow, count($units) - 1); $bytes /= (1 \u0026lt;\u0026lt; (10 * $pow)); return round($bytes, $precision) . \u0026#34; \u0026#34; . $units[$pow]; } print formatBytes(memory_get_peak_usage()); // from reading-files-line-by-line-1.php function readTheFile($path) { $lines = []; $handle = fopen($path, \u0026#34;r\u0026#34;); while(!feof($handle)) { $lines[] = trim(fgets($handle)); } fclose($handle); return $lines; } readTheFile(\u0026#34;shakespeare.txt\u0026#34;); require \u0026#34;memory.php\u0026#34;; 我们读取一个文本文件为莎士比亚全集。文件大小为5.5MB，内存占用峰值为12.8MB。现在让我们用一个生成器来读取每一行：\n// from reading-files-line-by-line-2.php function readTheFile($path) { $handle = fopen($path, \u0026#34;r\u0026#34;); while(!feof($handle)) { yield trim(fgets($handle)); } fclose($handle); } readTheFile(\u0026#34;shakespeare.txt\u0026#34;); require \u0026#34;memory.php\u0026#34;; 文本文件大小不变，但内存使用峰值只是393KB。即使我们能把读取到的数据做一些事情也并不意味着什么。也许我们可以在看到两条空白时把文档分割成块，像这样：\n// from reading-files-line-by-line-3.php $iterator = readTheFile(\u0026#34;shakespeare.txt\u0026#34;); $buffer = \u0026#34;\u0026#34;; foreach ($iterator as $iteration) { preg_match(\u0026#34;/\\n{3}/\u0026#34;, $buffer, $matches); if (count($matches)) { print \u0026#34;.\u0026#34;; $buffer = \u0026#34;\u0026#34;; } else { $buffer .= $iteration . PHP_EOL; } } require \u0026#34;memory.php\u0026#34;; 猜到我们使用了多少内存吗？我们把文档分割为1216块，仍然只使用了459KB的内存，这是否让你惊讶？考虑到生成器的性质，我们使用的最多内存是使用在迭代中我们需要存储的最大文本块。在本例中，最大的块为101985字符。\n我已经撰写了使用生成器提示性能和Nikita Popov的迭代器库，如果你感兴趣就去看看吧！\n生成器还有其它用途，但是最明显的好处就是高性能读取大文件。如果我们需要处理这些数据，生成器可能是最好的方法。\n管道间的文件 在我们不需要处理数据的情况下，我们可以把文件数据传递到另一个文件。通常被称为管道（大概是因为我们看不到除了两端的管子里面，当然，它也是不透明的），我们可以通过使用流方法实现。让我们先写一个脚本从一个文件传到另一个文件。这样我们可以测量内存的占用情况：\n// from piping-files-1.php file_put_contents( \u0026#34;piping-files-1.txt\u0026#34;, file_get_contents(\u0026#34;shakespeare.txt\u0026#34;) ); require \u0026#34;memory.php\u0026#34;; 不出所料，这个脚本使用更多的内存来进行文本文件复制。这是因为它读取(和保留)文件内容在内存中，直到它被写到新文件中。对于小文件这种方法也许没问题。当为更大的文件时，就捉襟见肘了…\n让我们尝试用流(管道)来传送一个文件到另一个：\n// from piping-files-2.php $handle1 = fopen(\u0026#34;shakespeare.txt\u0026#34;, \u0026#34;r\u0026#34;); $handle2 = fopen(\u0026#34;piping-files-2.txt\u0026#34;, \u0026#34;w\u0026#34;); stream_copy_to_stream($handle1, $handle2); fclose($handle1); fclose($handle2); require \u0026#34;memory.php\u0026#34;; 这段代码稍微有点陌生。我们打开了两文件的句柄，第一个是只读模式，第二个是只写模式，然后我们从第一个复制到第二个中。最后我们关闭了它，也许使你惊讶，内存只占用了393KB\n这似乎很熟悉。像代码生成器在存储它读到的每一行代码？那是因为第二个参数fgets规定了每行读多少个字节（默认值是-1或者直到下一行为止）。\n第三个参数stream_copy_to_stream和第二个参数是同一类参数（默认值相同），stream_copy_to_stream一次从一个数据流里读一行，同时写到另一个数据流里。它跳过生成器只有一个值的部分（因为我们不需要这个值）。\n这篇文章对于我们来说可能是没用的，所以让我们想一些我们可能会用到的例子。假设我们想从我们的CDN中输出一张图片，作为一种重定向的路由应用程序。我们可以参照下边的代码来实现它：\n// from piping-files-3.php file_put_contents( \u0026#34;piping-files-3.jpeg\u0026#34;, file_get_contents( \u0026#34;https://github.com/assertchris/uploads/raw/master/rick.jpg\u0026#34; ) ); // ...or write this straight to stdout, if we don\u0026#39;t need the memory info require \u0026#34;memory.php\u0026#34;; 设想一下，一个路由应用程序让我们看到这段代码。但是，我们想从CDN获取一个文件，而不是从本地的文件系统获取。我们可以用一些其他的东西来更好的替换file_get_contents（就像Guzzle），即使在引擎内部它们几乎是一样的。\n图片的内存大概有581K。现在，让我们来试试这个\n// from piping-files-4.php $handle1 = fopen( \u0026#34;https://github.com/assertchris/uploads/raw/master/rick.jpg\u0026#34;, \u0026#34;r\u0026#34; ); $handle2 = fopen( \u0026#34;piping-files-4.jpeg\u0026#34;, \u0026#34;w\u0026#34; ); // ...or write this straight to stdout, if we don\u0026#39;t need the memory info stream_copy_to_stream($handle1, $handle2); fclose($handle1); fclose($handle2); require \u0026#34;memory.php\u0026#34;; 内存使用明显变少（大概400K），但是结果是一样的。如果我们不关注内存信息，我们依旧可以用标准模式输出。实际上，PHP提供了一个简单的方式来完成：\n$handle1 = fopen( \u0026#34;https://github.com/assertchris/uploads/raw/master/rick.jpg\u0026#34;, \u0026#34;r\u0026#34; ); $handle2 = fopen( \u0026#34;php://stdout\u0026#34;, \u0026#34;w\u0026#34; ); stream_copy_to_stream($handle1, $handle2); fclose($handle1); fclose($handle2); // require \u0026#34;memory.php\u0026#34;; 其它流 还有其它一些流，我们可以通过管道来写入和读取（或只读取/只写入）：\nphp://stdin (只读) php://stderr (只写, 如php://stdout) php://input (只读) 这使我们能够访问原始请求体 php://output (只写) 让我们写入输出缓冲区 php://memory 和 php://temp (读-写) 是我们可以临时存储数据的地方。 不同之处在于一旦它变得足够大 php://temp 会将数据存储在文件系统中，而 php://memory 将一直持存储在内存中直到资源耗尽。 过滤器 还有一个我们可以在stream上使用的技巧，称为过滤器。它们是一种中间的步骤，提供对stream数据的一些控制，但不把他们暴露给我们。想象一下，我们会使用Zip扩展名来压缩我们的shakespeare.txt文件。\n// from filters-1.php $zip = new ZipArchive(); $filename = \u0026#34;filters-1.zip\u0026#34;; $zip-\u0026gt;open($filename, ZipArchive::CREATE); $zip-\u0026gt;addFromString(\u0026#34;shakespeare.txt\u0026#34;, file_get_contents(\u0026#34;shakespeare.txt\u0026#34;)); $zip-\u0026gt;close(); require \u0026#34;memory.php\u0026#34;; 这是一小段整洁的代码，但它测量内存占用在10.75MB左右。使用过滤器的话，我们可以减少内存：\n// from filters-2.php $handle1 = fopen( \u0026#34;php://filter/zlib.deflate/resource=shakespeare.txt\u0026#34;, \u0026#34;r\u0026#34; ); $handle2 = fopen( \u0026#34;filters-2.deflated\u0026#34;, \u0026#34;w\u0026#34; ); stream_copy_to_stream($handle1, $handle2); fclose($handle1); fclose($handle2); require \u0026#34;memory.php\u0026#34;; 此处，我们可以看到名为php://filter/zlib.deflate的过滤器，它读取并压缩资源的内容。我们可以在之后将压缩数据导出到另一个文件中。这仅使用了896KB.\n我知道这是不一样的格式，或者制作zip存档是有好处的。你不得不怀疑：如果你可以选择不同的格式并节省约12倍的内存，为什么不选呢？\n为了解压此数据，我们可以通过执行另一个zlib filter将压缩后的数据还原：\n// from filters-2.php file_get_contents( \u0026#34;php://filter/zlib.inflate/resource=filters-2.deflated\u0026#34; ); Streams have been extensively covered in Stream在“理解PHP中的流”和“高效使用PHP中的流”中已经被全面介绍了。如果你喜欢一个完全不同的视角，可以阅读一下。\n定制流 fopen和file_get_contents有它们自己的一套默认选项，但是这些都是完全可定制的。为了定义它们，我们需要创建一个新的流上下文：\n// from creating-contexts-1.php $data = join(\u0026#34;\u0026amp;\u0026#34;, [ \u0026#34;twitter=assertchris\u0026#34;, ]); $headers = join(\u0026#34;\\r\\n\u0026#34;, [ \u0026#34;Content-type: application/x-www-form-urlencoded\u0026#34;, \u0026#34;Content-length: \u0026#34; . strlen($data), ]); $options = [ \u0026#34;http\u0026#34; =\u0026gt; [ \u0026#34;method\u0026#34; =\u0026gt; \u0026#34;POST\u0026#34;, \u0026#34;header\u0026#34;=\u0026gt; $headers, \u0026#34;content\u0026#34; =\u0026gt; $data, ], ]; $context = stream_content_create($options); $handle = fopen(\u0026#34;https://example.com/register\u0026#34;, \u0026#34;r\u0026#34;, false, $context); $response = stream_get_contents($handle); fclose($handle); 在这个例子中，我们正在尝试向API发出POST请求。 API终端是安全的，但我们仍然需要使用http上下文属性（用于http和https）。我们设置一些消息头参数，并打开一个文件句柄到API。由于上下文处理写操作，我们可以将句柄打开为只读。\n查看文档了解更多。\n制定自定义协议和过滤器 在我们结束之前，让我们谈谈制定自定义协议。 如果你查看文档，你可以找到一个示例类来实现：\nProtocol { public resource $context; public __construct ( void ) public __destruct ( void ) public bool dir_closedir ( void ) public bool dir_opendir ( string $path , int $options ) public string dir_readdir ( void ) public bool dir_rewinddir ( void ) public bool mkdir ( string $path , int $mode , int $options ) public bool rename ( string $path_from , string $path_to ) public bool rmdir ( string $path , int $options ) public resource stream_cast ( int $cast_as ) public void stream_close ( void ) public bool stream_eof ( void ) public bool stream_flush ( void ) public bool stream_lock ( int $operation ) public bool stream_metadata ( string $path , int $option , mixed $value ) public bool stream_open ( string $path , string $mode , int $options , string \u0026amp;$opened_path ) public string stream_read ( int $count ) public bool stream_seek ( int $offset , int $whence = SEEK_SET ) public bool stream_set_option ( int $option , int $arg1 , int $arg2 ) public array stream_stat ( void ) public int stream_tell ( void ) public bool stream_truncate ( int $new_size ) public int stream_write ( string $data ) public bool unlink ( string $path ) public array url_stat ( string $path , int $flags ) } 我们不打算实现其中的一个，因为我认为它应该有自己的教程。这里有很多工作需要完成。但是一旦这个工作完成，我们可以很容易地注册我们的流包装：\nif (in_array(\u0026#34;highlight-names\u0026#34;, stream_get_wrappers())) { stream_wrapper_unregister(\u0026#34;highlight-names\u0026#34;); } stream_wrapper_register(\u0026#34;highlight-names\u0026#34;, \u0026#34;HighlightNamesProtocol\u0026#34;); $highlighted = file_get_contents(\u0026#34;highlight-names://story.txt\u0026#34;); 同样，也可以创建自定义流过滤器。该文档有一个示例过滤器类：\nFilter { public $filtername; public $params public int filter ( resource $in , resource $out , int \u0026amp;$consumed , bool $closing ) public void onClose ( void ) public bool onCreate ( void ) } 这可以很容易地注册：\n$handle = fopen(\u0026#34;story.txt\u0026#34;, \u0026#34;w+\u0026#34;); stream_filter_append($handle, \u0026#34;highlight-names\u0026#34;, STREAM_FILTER_READ); 突出显示名称需要匹配新的筛选器类的filtername属性。也可以在php：//filter/highligh-names/resource=story.txt字符串中使用自定义过滤器。定义过滤器比定义协议要容易得多。因为协议需要处理目录操作，而过滤器只需处理每个数据块。\n如果你有这个想法，我强烈建议你尝试创建自定义协议和过滤器。如果你可以将过滤器应用于stream_copy_to_streamoperations，那么即使在使用大容量文件时，你的应用程序也可以在没有内存的情况下使用。想象一下，编写一个调整大小的图像过滤器或加密的应用程序过滤器。\n总结 虽然这不是我们经常遇到的问题，但在处理大文件时很容易搞砸。在异步应用程序中，当我们不注意小心使用内存的话，很容易导致整个服务器宕机。 本教程希望向你介绍一些新的想法（或者让你重新认识他们），以便你可以更多地考虑如何高效地读取和写入大型文件。当我们开始熟悉流程和生成器，并停止使用像file_get_contents这样的函数时，我们的应用程序中就会减少错误的类别，这看起来是很好。\n","permalink":"https://lorenwe.eu.org/posts/tech/%E5%A6%82%E4%BD%95%E7%94%A8php%E8%AF%BB%E5%8F%96%E5%A4%A7%E6%96%87%E4%BB%B6/","summary":"\u003cp\u003e在 \u003ca href=\"https://github.com/sitepoint-editors/sitepoint-performant-reading-of-big-files-in-php\"\u003eGitHub\u003c/a\u003e 上可以找到本教程的源码。\u003c/p\u003e\n\u003ch3 id=\"衡量成功的标准\"\u003e衡量成功的标准\u003c/h3\u003e\n\u003cp\u003e确保我们对代码有改进的唯一方法是测试一个不好的情况，然后将我们修复之后的测量与另一个进行比较。换句话说，除非我们知道“解决方案”对我们有多大的帮助（如果有的话），否则我们不知道它是否真的是一个解决方案。\u003c/p\u003e\n\u003cp\u003e这里有两个我们可以关系的衡量标准。首先是CPU使用率。我们要处理的进程有多快或多慢？第二是内存使用情况。脚本执行时需要多少内存？这两个通常是成反比的 - 这意味着我们可以以CPU使用率为代价来降低内存使用，反之亦然。\u003c/p\u003e","title":"如何用PHP读取大文件"},{"content":"前言 HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。\n我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行请求行、请求头、消息主体。类似于下面这样：\n\u0026lt;method\u0026gt; \u0026lt;request-URL\u0026gt; \u0026lt;version\u0026gt; \u0026lt;headers\u0026gt; \u0026lt;entity-body\u0026gt; 协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。\n但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们。\napplication/x-www-form-urlencoded 这应该是最常见的 POST 提交数据的方式了。浏览器的原生 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：\nPOST http://www.example.com HTTP/1.1 Content-Type: application/x-www-form-urlencoded;charset=utf-8 title=test\u0026amp;sub%5B%5D=1\u0026amp;sub%5B%5D=2\u0026amp;sub%5B%5D=3 首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1\u0026amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。例如 PHP 中，$_POST['title'] 可以获取到 title 的值，$_POST['sub'] 可以得到 sub 数组。\n很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8」。\nmultipart/form-data 这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 \u0026lt;form\u0026gt; 表单的 enctype 等于 multipart/form-data。直接来看一个请求示例：\nPOST http://www.example.com HTTP/1.1 Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=\u0026#34;text\u0026#34; title ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;chrome.png\u0026#34; Content-Type: image/png PNG ... content of chrome.png ... ------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束。关于 multipart/form-data 的详细定义，请前往 rfc1867 查看。\n这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。\n上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 \u0026lt;form\u0026gt; 表单也只支持这两种方式（通过 \u0026lt;form\u0026gt; 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。\n随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。\napplication/json application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。\nJSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。\nGoogle 的 AngularJS 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码：\nvar data = {\u0026#39;title\u0026#39;:\u0026#39;test\u0026#39;, \u0026#39;sub\u0026#39; : [1,2,3]}; $http.post(url, data).success(function(result) { ... }); 最终发送的请求是：\nPOST http://www.example.com HTTP/1.1 Content-Type: application/json;charset=utf-8 {\u0026#34;title\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;sub\u0026#34;:[1,2,3]} 这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。一些 php 框架已经开始这么做了。\n当然 AngularJS 也可以配置为使用 x-www-form-urlencoded 方式提交数据。\ntext/xml 它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的：\nPOST http://www.example.com HTTP/1.1 Content-Type: text/xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;methodCall\u0026gt; \u0026lt;methodName\u0026gt;examples.getStateName\u0026lt;/methodName\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt;\u0026lt;i4\u0026gt;41\u0026lt;/i4\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/methodCall\u0026gt; XML-RPC 协议简单、功能够用，各种语言的实现都有。JavaScript 中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。不过，我个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。\n","permalink":"https://lorenwe.eu.org/posts/tech/%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84post%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F/","summary":"\u003ch3 id=\"前言\"\u003e前言\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://www.ietf.org/rfc/rfc2616.txt\"\u003eHTTP/1.1\u003c/a\u003e 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。\u003c/p\u003e\n\u003cp\u003e我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行请求行、请求头、消息主体。类似于下面这样：\u003c/p\u003e","title":"四种常见的POST提交数据方式"},{"content":"引言 最近在尝试基于 PHP 做一个反向代理 HTTP 的程序，其中一个需求是将程序收到的HTTP请求还原回 RFC2616 的原始格式。\n在处理的过程中遇到的问题主要在请求体的处理上。利用PHP的封装协议机制，我们可以通过读取 php://input 访问原始的POST信息。但这种方式有一个局限，对于 multipart/form-data 的请求来说，为了支持文件上传的操作，PHP会预先把请求体中的文件暂存到临时文件夹，并把参数解析到变量 $_POST 和 $_FILES 中， php://input 获取原始请求的功能也随之失效。\nStack Overflow 上的相关问题给出的 解决办法 是修改服务器配置，把发到 PHP 脚本的 Content-Type: multipart/form-data; boundary=xxxx 修改为其它格式，使其不经过PHP的 form-data 解析；或是把 php.ini 配置关于POST数据解析的 enable_post_data_reading = Off 选项关闭。然而这两种方法并不非常具有普遍性，在某些PHP配置文件不可控的共享主机的环境下并不适用。\n于是引出了本文讨论的话题 — 如何重新组装 multipart/form-data 格式的原始 POST 请求体。\nmultipart/form-data 格式 在POST请求中，一般表单会通过 application/x-www-form-urlencoded 格式上传，但此格式的数据仅支持文本格式，不支持二进制文件的上传。为了支持表单 POST 文件上传，RFC1867 定义了 multipart/form-data 的数据格式，实现了通过POST请求上传表单的内容以及二进制文件数据，关于数据的形态，参考 四种常见的 POST 提交数据方式 | JerryQu 的小站 。\nRFC1867 对于 multipart/form-data 的数据格式主要在MIME RFC1521 7.2.1 小节定义的。另外，在MIME 标准 Media Types 部分 RFC2046 的 5.1.1 节中，对于 multipart-body 的格式有一个较为清晰的 BNF 范式的语法定义，简短总结如下（来自 Stack Overflow） ：\nmultipart-body := [preamble CRLF] dash-boundary CRLF body-part *encapsulation close-delimiter [CRLF epilogue] dash-boundary := \u0026#34;--\u0026#34; boundary body-part := MIME-part-headers [CRLF *OCTET] encapsulation := delimiter CRLF body-part delimiter := CRLF dash-boundary close-delimiter := delimiter \u0026#34;--\u0026#34; 还原 multipart/form-data 的代码 写代码前搜索前人的经验，在 SegmentFault 看到了一位前辈的实现，参考前辈的代码，以及 RFC2046 的 BNF 语法定义，写了以下代码：\n// 还原 rfc1867, rfc2046 格式的FormData function getFormData() { // body-part array $body = array(); // 普通参数 foreach ($_POST as $key =\u0026gt; $value) { $body_part = \u0026#34;Content-Disposition: form-data; name=\\\u0026#34;$key\\\u0026#34;\\r\\n\u0026#34;; $body_part .= \u0026#34;\\r\\n$value\u0026#34;; $body[] = $body_part; } // 上传文件处理 foreach ($_FILES as $key =\u0026gt; $value) { $body_part = \u0026#34;Content-Disposition: form-data; name=\\\u0026#34;$key\\\u0026#34;; filename=\\\u0026#34;{$value[\u0026#39;name\u0026#39;]}\\\u0026#34;\\r\\n\u0026#34;; $body_part .= \u0026#34;Content-type: {$value[\u0026#39;type\u0026#39;]}\\r\\n\u0026#34;; $body_part .= \u0026#34;\\r\\n\u0026#34;.file_get_contents($value[\u0026#39;tmp_name\u0026#39;]); $body[] = $body_part; } // 提取boundary $boundary = substr($_SERVER[\u0026#39;CONTENT_TYPE\u0026#39;], strpos($_SERVER[\u0026#39;CONTENT_TYPE\u0026#39;], \u0026#34;=\u0026#34;) + 1); // multipart-body $multipart_body = \u0026#34;--$boundary\\r\\n\u0026#34;; // 拼接各个域 $multipart_body .= implode(\u0026#34;\\r\\n--$boundary\\r\\n\u0026#34;, $body); // 最后一个不同的 boundary $multipart_body .= \u0026#34;\\r\\n--$boundary--\u0026#34;; return $multipart_body; } 数组类型参数的支持 以上代码在大多数情况下工作正常，但未考虑到请求参数的类型为数组的情况。\n在PHP解释器源码的测试用例中，我们可以找到许多数组类型参数的测试，部分摘录如下：\na[]=1 a[]=1\u0026amp;a[]=1 a[]=1\u0026amp;a[0]=5 a[a]=1\u0026amp;a[b]=3 a[]=1\u0026amp;a[a]=1\u0026amp;a[b]=3 a[][]=1\u0026amp;a[][]=3\u0026amp;b[a][b][c]=1\u0026amp;b[a][b][d]=1 a=1\u0026amp;b=ZYX\u0026amp;c[][][][][][][][][][][][][][][][][][][][][][]=123\u0026amp;d=123\u0026amp;e[][]][]=3 Content-Type: multipart/form-data; boundary=---------------------------20896060251896012921717172737 -----------------------------20896060251896012921717172737 Content-Disposition: form-data; name=\u0026#34;file[]\u0026#34;; filename=\u0026#34;file1.txt\u0026#34; Content-Type: text/plain-file1 1 -----------------------------20896060251896012921717172737 Content-Disposition: form-data; name=\u0026#34;file[2]\u0026#34;; filename=\u0026#34;file2.txt\u0026#34; Content-Type: text/plain-file2 2 -----------------------------20896060251896012921717172737 Content-Disposition: form-data; name=\u0026#34;file[]\u0026#34;; filename=\u0026#34;file3.txt\u0026#34; Content-Type: text/plain-file3 3 -----------------------------20896060251896012921717172737-- 在PHP源码的 main/php_variables.c 中的 php_register_variable_ex 函数中，我们可以看到相关的处理：\n/* 99-110行 */ /* ensure that we don\u0026#39;t have spaces or dots in the variable name (not binary safe) */ for (p = var; *p; p++) { if (*p == \u0026#39; \u0026#39; || *p == \u0026#39;.\u0026#39;) { *p=\u0026#39;_\u0026#39;; } else if (*p == \u0026#39;[\u0026#39;) { is_array = 1; ip = p; *p = 0; break; } } var_len = p - var; /* 229-235行 */ ip++; if (*ip == \u0026#39;[\u0026#39;) { is_array = 1; *ip = 0; } else { goto plain_var; } 可见，在还原POST数据的时候，我们还需要考虑到参数为数组的情况。\n这里通过一个简单的 DFS 算法深度优先遍历数组，生成类似 a[0], a[1][1] 的字符串来实现：\n\u0026lt;?php $arr = [ \u0026#39;key1\u0026#39; =\u0026gt; [ \u0026#39;_key1\u0026#39; =\u0026gt; 23333, \u0026#39;_key2\u0026#39; =\u0026gt; 66666, ], \u0026#39;key2\u0026#39; =\u0026gt; \u0026#34;hahah\u0026#34;, \u0026#34;test\u0026#34;, ]; var_dump($arr); function dfs(\u0026amp;$node, $prefix, \u0026amp;$result) { if (!is_array($node)) { $result[$prefix] = $node; } else { foreach ($node as $key =\u0026gt; $value) { dfs($value, \u0026#34;{$prefix}[{$key}]\u0026#34;, $result); } } } dfs($arr, \u0026#34;arr\u0026#34;, $result); foreach ($result as $key =\u0026gt; $value) { echo \u0026#34;$key = $value\\n\u0026#34;; } 运行结果：\narray(3) { [\u0026#34;key1\u0026#34;]=\u0026gt; array(2) { [\u0026#34;_key1\u0026#34;]=\u0026gt; int(23333) [\u0026#34;_key2\u0026#34;]=\u0026gt; int(66666) } [\u0026#34;key2\u0026#34;]=\u0026gt; string(5) \u0026#34;hahah\u0026#34; [0]=\u0026gt; string(4) \u0026#34;test\u0026#34; } arr[key1][_key1] = 23333 arr[key1][_key2] = 66666 arr[key2] = hahah arr[0] = test 至于 $_FILES 数组，这里有一个反直觉的情况，具体在文档中也有人提出： PHP: POST method uploads - Manual\n简单地说，当表单中文件域的key为数组形式时，拿到的 $_FILES 数组类似如下的格式：\narray(1) { [\u0026#34;key\u0026#34;]=\u0026gt; array(5) { [\u0026#34;name\u0026#34;]=\u0026gt; array(2) { [0]=\u0026gt; string(8) \u0026#34;test.txt\u0026#34; [1]=\u0026gt; array(1) { [0]=\u0026gt; string(8) \u0026#34;test.txt\u0026#34; } } [\u0026#34;type\u0026#34;]=\u0026gt; array(2) { [0]=\u0026gt; string(10) \u0026#34;text/plain\u0026#34; [1]=\u0026gt; array(1) { [0]=\u0026gt; string(10) \u0026#34;text/plain\u0026#34; } } [\u0026#34;tmp_name\u0026#34;]=\u0026gt; array(2) { [0]=\u0026gt; string(14) \u0026#34;/tmp/phpKHCoSt\u0026#34; [1]=\u0026gt; array(1) { [0]=\u0026gt; string(14) \u0026#34;/tmp/phpSgtRHe\u0026#34; } } [\u0026#34;error\u0026#34;]=\u0026gt; array(2) { [0]=\u0026gt; int(0) [1]=\u0026gt; array(1) { [0]=\u0026gt; int(0) } } [\u0026#34;size\u0026#34;]=\u0026gt; array(2) { [0]=\u0026gt; int(8) [1]=\u0026gt; array(1) { [0]=\u0026gt; int(8) } } } } 假设我的目标是 key[1][0] 的 name 属性，在PHP中我们需要通过 $_FILES[\u0026ldquo;key\u0026rdquo;][\u0026ldquo;name\u0026rdquo;][1][0] 来访问，而在 $_FILES[\u0026ldquo;key\u0026rdquo;][\u0026ldquo;name\u0026rdquo;] 中，后面的索引的层级并不确定的，我们也不能简单地指定 [1][0] 来访问 $_FILES[\u0026ldquo;key\u0026rdquo;][\u0026ldquo;name\u0026rdquo;][1][0]。所以这里得有一些 hack 来优化一下这个过程，这里我实现了一个 query_multidimensional_array 函数，具体看最终的代码。\ngetFormData() 代码实现 以下是整个函数的完整实现：\n// 还原 rfc1867, rfc2046 格式的FormData function getFormData() { // body-part array $body = array(); // 普通参数 foreach ($_POST as $key =\u0026gt; $value) { if (!is_array($value)) { $body_part = \u0026#34;Content-Disposition: form-data; name=\\\u0026#34;$key\\\u0026#34;\\r\\n\u0026#34;; $body_part .= \u0026#34;\\r\\n$value\u0026#34;; $body[] = $body_part; } else { // 数组的情况处理 如 param1[]=xxxx $result = array(); convert_array_key($value, $key, $result); foreach ($result as $k =\u0026gt; $v) { $body_part = \u0026#34;Content-Disposition: form-data; name=\\\u0026#34;$k\\\u0026#34;\\r\\n\u0026#34;; $body_part .= \u0026#34;\\r\\n$v\u0026#34;; $body[] = $body_part; } } } // 上传文件处理 foreach ($_FILES as $key =\u0026gt; $value) { if (!is_array($value[\u0026#39;type\u0026#39;])) { $body_part = \u0026#34;Content-Disposition: form-data; name=\\\u0026#34;$key\\\u0026#34;; filename=\\\u0026#34;{$value[\u0026#39;name\u0026#39;]}\\\u0026#34;\\r\\n\u0026#34;; $body_part .= \u0026#34;Content-type: {$value[\u0026#39;type\u0026#39;]}\\r\\n\u0026#34;; $body_part .= \u0026#34;\\r\\n\u0026#34;.file_get_contents($value[\u0026#39;tmp_name\u0026#39;]); $body[] = $body_part; } else { // 文件key是数组的情况 如 file1[]=xxxx $result = array(); convert_array_key($value[\u0026#39;type\u0026#39;], \u0026#34;\u0026#34;, $result); foreach ($result as $k =\u0026gt; $v) { $filename = query_multidimensional_array($value[\u0026#39;name\u0026#39;], $k); $type = query_multidimensional_array($value[\u0026#39;type\u0026#39;], $k); $tmp_name = query_multidimensional_array($value[\u0026#39;tmp_name\u0026#39;], $k); $body_part = \u0026#34;Content-Disposition: form-data; name=\\\u0026#34;{$key}{$k}\\\u0026#34;; filename=\\\u0026#34;{$filename}\\\u0026#34;\\r\\n\u0026#34;; $body_part .= \u0026#34;Content-type: {$type}\\r\\n\u0026#34;; $body_part .= \u0026#34;\\r\\n\u0026#34;.file_get_contents($tmp_name); $body[] = $body_part; } } } // 提取boundary $boundary = substr($_SERVER[\u0026#39;CONTENT_TYPE\u0026#39;], strpos($_SERVER[\u0026#39;CONTENT_TYPE\u0026#39;], \u0026#34;=\u0026#34;) + 1); // multipart-body $multipart_body = \u0026#34;--$boundary\\r\\n\u0026#34;; // 拼接各个域 $multipart_body .= implode(\u0026#34;\\r\\n--$boundary\\r\\n\u0026#34;, $body); // 最后一个不同的 boundary $multipart_body .= \u0026#34;\\r\\n--$boundary--\u0026#34;; return $multipart_body; } // 直接访问多维数组元素 // query: [0][0] -\u0026gt; $array[0][0] function query_multidimensional_array(\u0026amp;$array, $query) { $query = explode(\u0026#39;][\u0026#39;, substr($query, 1, -1)); $temp = $array; foreach ($query as $key) { $temp = $temp[$key]; } return $temp; } // DFS将数组变为一维形式 function convert_array_key(\u0026amp;$node, $prefix, \u0026amp;$result) { if (!is_array($node)) { $result[$prefix] = $node; } else { foreach ($node as $key =\u0026gt; $value) { convert_array_key($value, \u0026#34;{$prefix}[{$key}]\u0026#34;, $result); } } } 至此，在PHP脚本中，只需调用 getFormData() ，即可获得 multipart/form-data 请求的原始数据，通过以下代码可以实现一键获取请求原始POST Body。\n需要注意的是，若数组类型参数是 a[] 这种形式，经过本函数还原后会补充具体的下标，比如说这里的 a[] 会被处理成 a[0] ，a[][] 则为 a[0][0]。从而导致了 POST Body 长度发生变化，若结果需要用于发包等操作，我们需要重新计算 Content-Length ，避免请求出现问题。\nif (@$_SERVER[\u0026#39;CONTENT_TYPE\u0026#39;] \u0026amp;\u0026amp; strpos($_SERVER[\u0026#39;CONTENT_TYPE\u0026#39;], \u0026#34;multipart/form-data\u0026#34;) !== false) { $body = getFormData(); $content_length = strlen($body); } else { $body = file_get_contents(\u0026#39;php://input\u0026#39;); } PHP中以multipart/form-data上传文件流 上传类:\nclass UploadPart { protected static $url; protected static $delimiter; protected static $instance; public function __construct() { static::$url = \u0026#39;上传地址\u0026#39;; static::$delimiter = uniqid(); // 生成 } public function putPart($param) { $post_data = static::buildData($param); $curl = curl_init(static::$url); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl, CURLOPT_POST, true); curl_setopt($curl, CURLOPT_POSTFIELDS, $post_data); curl_setopt($curl, CURLOPT_HTTPHEADER, [ \u0026#34;Content-Type: multipart/form-data; boundary=\u0026#34; . static::$delimiter, \u0026#34;Content-Length: \u0026#34; . strlen($post_data) ]); $response = curl_exec($curl); curl_close($curl); $info = json_decode($response, true); if (!is_array($info[\u0026#39;Msg\u0026#39;]) \u0026amp;\u0026amp; $info[\u0026#39;Msg\u0026#39;] == $param[\u0026#39;filesize\u0026#39;]) { $param[\u0026#39;offset\u0026#39;] = $param[\u0026#39;filesize\u0026#39;]; $param[\u0026#39;upload\u0026#39;] = \u0026#39;\u0026#39;; return $this-\u0026gt;putPart($param); } return $response; } private static function buildData($param){ $data = \u0026#39;\u0026#39;; $eol = \u0026#34;\\r\\n\u0026#34;; $upload = $param[\u0026#39;upload\u0026#39;]; unset($param[\u0026#39;upload\u0026#39;]); foreach ($param as $name =\u0026gt; $content) { $data .= \u0026#34;--\u0026#34; . static::$delimiter . \u0026#34;\\r\\n\u0026#34; . \u0026#39;Content-Disposition: form-data; name=\u0026#34;\u0026#39; . $name . \u0026#34;\\\u0026#34;\\r\\n\\r\\n\u0026#34; . $content . \u0026#34;\\r\\n\u0026#34;; } // 拼接文件流 $data .= \u0026#34;--\u0026#34; . static::$delimiter . $eol . \u0026#39;Content-Disposition: form-data; name=\u0026#34;upload\u0026#34;; filename=\u0026#34;\u0026#39; . $param[\u0026#39;filename\u0026#39;] . \u0026#39;\u0026#34;\u0026#39; . \u0026#34;\\r\\n\u0026#34; . \u0026#39;Content-Type:application/octet-stream\u0026#39;.\u0026#34;\\r\\n\\r\\n\u0026#34;; $data .= $upload . \u0026#34;\\r\\n\u0026#34;; $data .= \u0026#34;--\u0026#34; . static::$delimiter . \u0026#34;--\\r\\n\u0026#34;; return $data; } public static function getInstance() { if(!static::$instance){ static::$instance = new static(); } return static::$instance; } } 使用方法\n$fields = array( \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;video\u0026#39;, \u0026#39;filename\u0026#39; =\u0026gt; \u0026#39;1407.png\u0026#39;, \u0026#39;filesize\u0026#39; =\u0026gt; 58701, \u0026#39;offset\u0026#39; =\u0026gt; 0, \u0026#39;filetype\u0026#39; =\u0026gt; \u0026#39;.acc\u0026#39;, \u0026#39;originName\u0026#39; =\u0026gt; \u0026#39;1407.png\u0026#39;, \u0026#39;upload\u0026#39;=\u0026gt;file_get_contents(\u0026#39;0407.png\u0026#39;) ); $part = UploadPart::getInstance()-\u0026gt;putPart($fields); 参考 RFC1521 RFC1867 RFC2046 PHP: POST 方法上传 - Manual PHP: 上传多个文件 - Manual PHP文件上传源码分析(RFC1867) | 风雪之隅 深入理解PHP原理之文件上传 | 风雪之隅 四种常见的 POST 提交数据方式 | JerryQu 的小站 php - Get raw post data - Stack Overflow http - Is this a well formed multipart/form-data request? - Stack Overflow http - 请问哪份 RFC 文档定义了 multipart/form-data 的格式？ - SegmentFault 思否 ","permalink":"https://lorenwe.eu.org/posts/tech/php%E6%9E%84%E9%80%A0form-data%E6%A0%BC%E5%BC%8Fpost%E8%AF%B7%E6%B1%82%E4%BD%93%E7%9A%84%E6%96%B9%E6%B3%95/","summary":"\u003ch3 id=\"引言\"\u003e引言\u003c/h3\u003e\n\u003cp\u003e最近在尝试基于 PHP 做一个反向代理 HTTP 的程序，其中一个需求是将程序收到的HTTP请求还原回 \u003ca href=\"https://www.ietf.org/rfc/rfc2616.txt\"\u003eRFC2616\u003c/a\u003e 的原始格式。\u003c/p\u003e\n\u003cp\u003e在处理的过程中遇到的问题主要在请求体的处理上。利用PHP的封装协议机制，我们可以通过读取 \u003ca href=\"https://www.php.net/manual/zh/wrappers.php.php\"\u003ephp://input\u003c/a\u003e 访问原始的POST信息。但这种方式有一个局限，对于 multipart/form-data 的请求来说，为了支持文件上传的操作，PHP会预先把请求体中的文件暂存到临时文件夹，并把参数解析到变量 $_POST 和 $_FILES 中， php://input 获取原始请求的功能也随之失效。\u003c/p\u003e","title":"PHP构造multipart/form-data格式POST请求体的方法"},{"content":"一、为什么要配置多个Git账号 文章写于2021年的最后一天，最近闲来无事，想搞个导航网站，至于为什么要自己搞，纯属兴趣，既然是兴趣，就想着不要投入太大，整个省心省力的方案，github pages走起，问题就来了，一个github账号只能CANAME一个域名，我刚好挂了一个博客，其他的仓库要pages就只能在我的博客域名后面跟上仓库名这样访问，这很不程序员，所以我就又注册了一个github账号，现在在我的win10电脑上就要使用两个github账户了，当我在我的电脑上给新注册的仓库推送代码时就会出现当前用户没有权限访问，至此，就只能想办法配置好多个用户访问了，其实实际工作中也会遇见这个问题，比如自己肯定有github账户，开发公司项目的时候可能会有公司的gitlab账户或者其他代码仓库的账户，如果是使用http方式拉取代码还好，账户密码一输，记住密码也就没有后续问题了，但如果是使用ssh拉取代码就懵逼了，今天就是来解决这个问题的\n二、初始化Git配置 默认我们都是已经使用了很久git，肯定做过很多设置了，为解决上面这个问题呢主要就是让git不再以一个用户身份对仓库进行更改，而是让它自动的选择对应的用户身份去操作代码仓库，只要用户身份和仓库对应上了，就没有权限问题啦，那就开干吧！\n1.去除全局用户配置 # 设置全局用户名 git config --golbal user.name \u0026#34;XXX\u0026#34; # 设置全局邮箱 git config --golbal user.email \u0026#34;xxx@aa.com\u0026#34; # 查看全局用户名 git config --global user.name # 查看全局邮箱 git config --global user.email # 查看全局密码 git config --global user.password 移除全局配置的用户信息\n# 移除全局配置账户 git config --global --unset user.name # 移除全局配置邮箱 git config --global --unset user.email # 移除全局密码 git config --global --unset user.password 如果上述命令执行有问题的话其实还可以自行更改git配置文件来实现\n如：找到C:\\Users\\Administrator\\.gitconfig文件，用文本编辑器打开找到[user]这一栏把所有的用户及邮箱信息删掉，就像这样：\n[user] [http] sslVerify = false 接下来运行命令来检查一下配置是否成功 git config --list\n$ git config --list core.symlinks=false core.autocrlf=true core.fscache=true color.diff=auto color.status=auto color.branch=auto color.interactive=true help.format=html rebase.autosquash=true http.sslbackend=openssl http.sslcainfo=C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt credential.helper=manager http.sslverify=false 没有看到用户信息就算完成了\n2.生成密钥对 因为是要通过ssh来推拉仓库，故我们要先生成ssh的key，生成的命令也很简单\nssh-keygen -t rsa -C \u0026#34;lorenwe@163.com\u0026#34; 在这先声明一下自己的用户体系，以后后面搞混乱了，我原来自有一个github账户名是lorenwe，现在又注册了一个名为lorenwe2的账户（取名是个麻烦事），邮箱呢都是用的163的，所以两个账户的邮箱是lorenwe@163.com和lorenwe2@163.com，接下来就是不同的操作来啦\n注意上面那条命令 ssh-keygen -t rsa -C \u0026quot;lorenwe@163.com\u0026quot; 执行完后会在用户目录也就是C:\\Users\\Administrator 目录的 .ssh 目录里面生成两个文件名为 id_rsa 和 id_rsa.pub 的两个文件，如果在执行命令前就有的话可能你之前已经配置了ssh key，如果知道key对应配置哪个网站的话，可以删除从新配置，如果不支持重新配置的话就不建议删除了，\n可以使用这个命令生成指定文件名的密钥对\nssh-keygen -t rsa -C \u0026#34;lorenwe@163.com\u0026#34; -f id_rsa_lorenwe 现在我们不指定，也就是说生成了上面所说的两个文件，然后对这两个文件进行重命名，为了好区分我就直接在后面加上用户名了，现在文件结构如下：\n接下来就是为第二个用户生成 ssh key，重复以上操作即可\nAdministrator@PC-20210304RNJZ MINGW64 ~/.ssh $ ssh-keygen -t rsa -C \u0026#34;lorenwe2@163.com\u0026#34; -f id_rsa_lorenwe2 Generating public/private rsa key pair. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in id_rsa_lorenwe2. Your public key has been saved in id_rsa_lorenwe2.pub. The key fingerprint is: SHA256:DwTCt/KL3YvvLEA9AFj/8BCGyRj/00EJLM4KXe+TCZk lorenwe2@163.com The key\u0026#39;s randomart image is: +---[RSA 2048]----+ |.*o*=.o. | |o.=o=+o. | | +.o+B... | |. +.E*=o | |.. .o=++S | |. ..* o | | + + . | | . +o. | | .+=. | +----[SHA256]-----+ 注意使用 -f 指定生成文件名时需要让命令行处于在 .ssh 目录下，因为指定文件名后生成的文件就处于命令行所在的文件夹，在 .ssh 目录下省去了再去移动文件这一步，现在我们的文件目录结构为：\n至此准备工作完成了。\n三、配置Github的 SSH 用户 lorenwe 登录 GitHub，进入【Settings】-【SSH and GPG keys】，如下截图： 点击【New SSH key】按钮，进入新建SSH key页面，复制 id_rsa_lorenwe.pub 文件内容粘贴到大框框中，如下配图： Title随便取一个，我这取的是邮箱，这样配置完了就知道我这个密钥是给哪个用户配置的\n打开另外一个浏览器登入lorenwe2 账户重复一遍上面操作即可，至此GitHub配置完成了，同样的道理我们也可以配置其他站点的 ssh key，如 gitee 等 四、测试配置是否成功 可以执行下面的命令来测试密钥配置，需要注意的是测试命令需要自己指定要使用的是哪个key，因为在.ssh目录下面有两个key，默认是使用id_rsa来验证的\nssh -T git@github.com -i ~/.ssh/id_rsa_lorenwe Hi lorenwe! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. ssh -T git@github.com -i ~/.ssh/id_rsa_lorenwe2 Hi lorenwe2! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 看到 successfully 就说明成功了\n五、Git配置不同站点使用不同用户 还是在.ssh目录下，创建一个文件名为 config 的文件，注意不带后缀，不是config.txt和config.ini，不带后缀就叫config，编辑器打开然后输入以下内容：\n# 配置user1 Host lorenwe.github.com HostName github.com IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_rsa_lorenwe PreferredAuthentications publickey User lorenwe # 配置user2 Host lorenwe2.github.com HostName github.com IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_rsa_lorenwe2 PreferredAuthentications publickey User lorenwe2 假如你还要配置公司内部的gitlab用户，那么可以按照下面的配置来修改\n# 配置user3 Host 192.168.12.5 Hostname 192.168.12.5 PreferredAuthentications publickey IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_rsa_gitlab User gitlab_name 最后.ssh目录的文件结构如下图：\n六、使用需要注意的地方 在github上创建好一个仓库，创建好后如下：\n注意到 仓库 clone 路径 ssh的方式\ngit@github.com:lorenwe2/lorenwe2.git 使用以下命令clone会发现出错了，具体如下\nAdministrator@PC-20210304RNJZ MINGW64 ~/Desktop/test $ git clone git@github.com:lorenwe2/lorenwe2.git Cloning into \u0026#39;lorenwe2\u0026#39;... git@github.com: Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 原因就是之前配置的config中是以下配置\n# 配置user1 Host lorenwe.github.com HostName github.com IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_rsa_lorenwe PreferredAuthentications publickey User lorenwe # 配置user2 Host lorenwe2.github.com HostName github.com IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_rsa_lorenwe2 PreferredAuthentications publickey User lorenwe2 两个用户的 HostName 都一样，git就从你给的clone链接里面拿到的host name也是github.com，这时候它就不知道要用哪个用户来clone了，解决办法很简单，把host再具体一点，如：\nAdministrator@PC-20210304RNJZ MINGW64 ~/Desktop/test $ git clone git@lorenwe2.github.com:lorenwe2/lorenwe2.git Cloning into \u0026#39;lorenwe2\u0026#39;... warning: You appear to have cloned an empty repository. 上面就clone 成功了，只是clone了一个空仓库，我们只是在github.com前面加上了用户名，那就刚好对应上了上面config配置的Host，git 就知道要用哪个用户去clone仓库了，配置里面还定义的key的路径，那key也正确，所以就正常clone下来了，再测试一下推送功能吧\nAdministrator@PC-20210304RNJZ MINGW64 ~/Desktop/test $ cd lorenwe2/ Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git status On branch master No commits yet Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) test.txt nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track) Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git add -A Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git commit -m \u0026#34;添加文件\u0026#34; *** Please tell me who you are. Run git config --global user.email \u0026#34;you@example.com\u0026#34; git config --global user.name \u0026#34;Your Name\u0026#34; to set your account\u0026#39;s default identity. Omit --global to set the identity only in this repository. fatal: unable to auto-detect email address (got \u0026#39;Administrator@PC-20210304RNJZ.(none)\u0026#39;) 可以发现命令执行到git commit时候就出错了，给的提示信息也很明显，没有设置全局用户名，不知道以什么用户身份去提交代码，我们不要按照他的说明来，他是要设置全局用户，但我们电脑是要使用多个用户的，所以设置全局用户显然不合适，可以使用以下命令为当前项目设置用户及邮箱\ngit config user.name \u0026#34;lorenwe2\u0026#34; git config user.email \u0026#34;lorenwe2@163.com\u0026#34; Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git config user.name \u0026#34;lorenwe2\u0026#34; Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git config user.email \u0026#34;lorenwe2@163.com\u0026#34; Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git commit -m \u0026#34;添加文件\u0026#34; [master (root-commit) 7bf22a5] 添加文件 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 test.txt Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git push Enumerating objects: 3, done. Counting objects: 100% (3/3), done. Writing objects: 100% (3/3), 214 bytes | 214.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To lorenwe2.github.com:lorenwe2/lorenwe2.git * [new branch] master -\u0026gt; master 从上面可以看出，推送一切也都是ok的，假如不是新的仓库，而且原先还是使用HTTPS通信，则可以修改远程仓库地址\ngit remote rm origin git remote add origin git@lorenwe2.github.com:xxx/xxxxx.git 再为这个仓库配置用户名和邮箱，就也能对旧仓库修改推送方式，如不知道旧仓库是如何配置的，可以打开仓库目录里的.git文件夹找到config文件查看即可，如图：\n打开后可看到如下类似内容\n[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true [remote \u0026#34;origin\u0026#34;] url = git@lorenwe2.github.com:lorenwe2/lorenwe2.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \u0026#34;master\u0026#34;] remote = origin merge = refs/heads/master [user] name = lorenwe2 email = lorenwe2@163.com 至此 win10 配置多个git账户算是完成啦\n","permalink":"https://lorenwe.eu.org/posts/tech/win10%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7/","summary":"\u003ch3 id=\"一为什么要配置多个git账号\"\u003e一、为什么要配置多个Git账号\u003c/h3\u003e\n\u003cp\u003e文章写于2021年的最后一天，最近闲来无事，想搞个导航网站，至于为什么要自己搞，纯属兴趣，既然是兴趣，就想着不要投入太大，整个省心省力的方案，github pages走起，问题就来了，一个github账号只能CANAME一个域名，我刚好挂了一个博客，其他的仓库要pages就只能在我的博客域名后面跟上仓库名这样访问，这很不程序员，所以我就又注册了一个github账号，现在在我的win10电脑上就要使用两个github账户了，当我在我的电脑上给新注册的仓库推送代码时就会出现当前用户没有权限访问，至此，就只能想办法配置好多个用户访问了，其实实际工作中也会遇见这个问题，比如自己肯定有github账户，开发公司项目的时候可能会有公司的gitlab账户或者其他代码仓库的账户，如果是使用http方式拉取代码还好，账户密码一输，记住密码也就没有后续问题了，但如果是使用ssh拉取代码就懵逼了，今天就是来解决这个问题的\u003c/p\u003e","title":"Win10配置多个Github账号"},{"content":" Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群 787018782\n","permalink":"https://lorenwe.eu.org/links/","summary":"\u003cdiv class=\"friend\"\u003e\n\u003ca target=\"_blank\" href=https://www.sulvblog.cn title=Sulv\u0026#39;s\u0026#32;Blog class=\"friendurl\"\u003e\n  \u003cdiv class=\"frienddiv\"\u003e\n    \u003cdiv class=\"frienddivleft\"\u003e\n      \u003cimg class=\"myfriend\" src=https://www.sulvblog.cn/img/Q.gif /\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"frienddivright\"\u003e\n      \u003cdiv class=\"friendname\"\u003eSulv\u0026#39;s Blog\u003c/div\u003e\n      \u003cdiv class=\"friendinfo\"\u003e一个记录技术、阅读、生活的博客\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/a\u003e\n\n\u003c/div\u003e\n\u003cbr/\u003e\n\u003cbr/\u003e\n\u003cbr/\u003e\n\u003cbr/\u003e\n\u003cbr/\u003e\n\u003cdiv style=\"font-size: 20px;\" class=\"youlian\"\u003e👉友链格式\u003c/div\u003e\n\u003cdiv style=\"font-size: 16px;\"\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e名称：\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eSulv\u0026rsquo;s Blog\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e网址：\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ca href=\"https://www.sulvblog.cn\"\u003ehttps://www.sulvblog.cn\u003c/a\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e图标：\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ca href=\"https://www.sulvblog.cn/img/Q.gif\"\u003ehttps://www.sulvblog.cn/img/Q.gif\u003c/a\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e描述：\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e一个记录技术、阅读、生活的博客\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003cbr/\u003e\n\u003cdiv style=\"font-size: 20px;\"\u003e👉友链申请要求\u003c/div\u003e\n\u003cblockquote\u003e\n\u003cp\u003e秉承互换友链原则、文章定期更新\u003c!-- 、网站在工信部备案 --\u003e、不能有太多广告、个人描述字数控制在15字内\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cbr/\u003e\n\u003cdiv style=\"font-size: 20px;\"\u003e👉Hugo博客交流群\u003c/div\u003e\n\u003cblockquote\u003e\n\u003cp\u003e787018782\u003c/p\u003e","title":"🤝友链"},{"content":"关于我\n英文名: Kevin Xu 职业: 程序员 运动: 跑步、乒乓球、爬山 ","permalink":"https://lorenwe.eu.org/about/","summary":"\u003cp style=\"font-size: 25px;\"\u003e关于我\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e英文名:\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eKevin Xu\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e职业:\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e程序员\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e运动:\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e跑步、乒乓球、爬山\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"🙋🏻‍♂️关于"}]