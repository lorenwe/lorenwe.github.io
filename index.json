[{"content":"一、简介 serde_yaml 是 Rust 语言中一个用于序列化和反序列化 YAML 数据的库。它以其高性能和灵活性而广受欢迎，特别适用于需要处理 YAML 配置文件的项目。在这篇博客中，我们将探讨 serde_yaml 的基本用法，并提供一些实用的示例代码。\n二、使用场景 serde_yaml 常用于以下场景：\n配置管理：许多应用程序使用 YAML 文件来存储配置参数，serde_yaml 可以轻松解析这些文件。 数据交换：在系统之间传递数据时，YAML 格式因其可读性而常被选用。 文档生成：一些工具使用 YAML 来描述文档结构，serde_yaml 可以帮助生成和解析这些文档。 三、基本使用 开始使用 serde_yaml 之前，先创建一个 serde_yaml_test 项目文件夹，在文件夹中使用 cargo init 初始化 rust 项目，然后在项目的 Cargo.toml 文件中添加依赖：\nserde = { version = \u0026quot;1.0\u0026quot;, features = [\u0026quot;derive\u0026quot;] } serde_yaml = \u0026quot;0.9.34\u0026quot; 要使用最新版本的 serde 的话可以使用命令行来添加依赖，如：\ncargo add serde --features=\u0026quot;derive\u0026quot; cargo add serde_yaml 依赖的包都准备完成后，就来看看几个示例，演示如何读取、解析和生成 YAML 文件。\n1、读取和解析 YAML 文件 以下是一个基本示例，展示了如何使用 serde_yaml 读取和解析一个名为 以下是一个基本示例，展示了如何使用 serde_yaml 读取和解析一个名为 hello.yml 的文件： 的文件：\n# 在项目根目录创建一个 hello.yml 文件 touch hello.yml # 此时目录结构为 #|-serde_yaml_test # |--src # |--target # |--.gitignore # |--Cargo.lock # |--Cargo.toml # |--hello.yml use std::collections::BTreeMap; use std::fs::File; use std::io::Read; use serde_yaml; fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error\u0026gt;\u0026gt; { let mut file = File::open(\u0026quot;hello.yml\u0026quot;)?; // 打开文件 hello.yml let mut contents = String::new(); // 创建一个字符串 file.read_to_string(\u0026amp;mut contents)?; // 读取文件内容到字符串缓冲区 println!(\u0026quot;YAML file contents:\\n{}\u0026quot;, contents); // 打印原始的YAML字符串 // 将YAML字符串反序列化为BTreeMap let deserialized_map: BTreeMap\u0026lt;String, serde_yaml::Value\u0026gt; = serde_yaml::from_str(\u0026amp;contents)?; println!(\u0026quot;Deserialized map: {:#?}\u0026quot;, deserialized_map); // 打印反序列化后的数据结构 if let Some(name) = deserialized_map.get(\u0026quot;name\u0026quot;).and_then(|v| v.as_str()) { println!(\u0026quot;name: {}\u0026quot;, name); // 打印 name } else { println!(\u0026quot;The key 'name' was not found or is not a string.\u0026quot;); } Ok(()) } // 输出结果： // Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.03s // Running `target\\debug\\serde_yaml_test.exe` // YAML file contents: // name: data // Deserialized map: { // \u0026quot;name\u0026quot;: String(\u0026quot;data\u0026quot;), // } // name: data 2、序列化数据结构为 YAML 示例展示了如何将一个 Rust 数据结构序列化为 YAML 格式的字符串：\nuse std::collections::BTreeMap; use serde_yaml; fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error\u0026gt;\u0026gt; { // 创建一个 BTreeMap 数据结构 let mut data = BTreeMap::new(); data.insert(\u0026quot;name\u0026quot;.to_string(), serde_yaml::Value::String(\u0026quot;Alice\u0026quot;.to_string())); data.insert(\u0026quot;age\u0026quot;.to_string(), serde_yaml::Value::Number(serde_yaml::Number::from(30))); // 将数据结构序列化为 YAML 字符串 let yaml_string = serde_yaml::to_string(\u0026amp;data)?; // 打印序列化后的 YAML 字符串 println!(\u0026quot;Serialized YAML:\\n{}\u0026quot;, yaml_string); Ok(()) } 3、使用自定义结构体进行反序列化 使用自定义结构体来解析 YAML 数据会更加方便和直观。以下示例展示了如何定义一个结构体并解析 YAML 数据：\nuse serde::{Deserialize, Serialize}; use serde_yaml; #[derive(Debug, Serialize, Deserialize)] struct Person { name: String, age: u8, } fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error\u0026gt;\u0026gt; { // 定义一个 YAML 字符串 let yaml_str = \u0026quot; name: Bob age: 25 \u0026quot;; // 将 YAML 字符串反序列化为 Person 结构体 let person: Person = serde_yaml::from_str(yaml_str)?; // 打印反序列化后的结构体 println!(\u0026quot;Deserialized person: {:?}\u0026quot;, person); Ok(()) } 4、从文件流中直接解析 有时，为了优化内存使用，可以直接从文件流中进行解析：\nuse serde::{Deserialize, Serialize}; use std::fs::File; #[derive(Debug, Serialize, Deserialize)] struct Config { database_url: String, port: u16, } fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error\u0026gt;\u0026gt; { // 打开配置文件 let file = File::open(\u0026quot;config.yml\u0026quot;)?; // 从文件流中直接反序列化 let config: Config = serde_yaml::from_reader(file)?; // 打印反序列化后的配置 println!(\u0026quot;Config: {:?}\u0026quot;, config); Ok(()) } 四、复杂 YAML 文件解析 基于以上案例，来尝试解析一个复杂的 yaml 文件，既然要复杂，那就尝试解析一下 docker-compose.yml文件吧！先来准备一个 yaml 文件，放在项目根目录下，如下：\nversion: \u0026quot;3.9\u0026quot; services: redis: image: redis:latest restart: always privileged: true ports: - 6379:6379 volumes: - ./data/redis/data:/data - ./redis/etc:/usr/local/etc/redis command: redis-server /usr/local/etc/redis/redis.conf nginx: image: nginx:latest restart: always privileged: true volumes: - ./nginx/etc/nginx:/etc/nginx - ./var/www:/var/www/html ports: - \u0026quot;80:80\u0026quot; - \u0026quot;443:443\u0026quot; depends_on: - redis networks: mynet1: driver: overlay attachable: false 再写代码之前，先把 rust 引入的包先贴出来，后面贴代码时可以少写一点啰嗦代码，只关注核心逻辑，看起来更清晰易懂，这是整个项目所依赖的包，也没有很多\nuse std::collections::HashMap; use std::fmt::{Debug, Display}; use std::fs::File; use std::io::Read; use serde::{Deserialize, Serialize}; 1.固定字段解析 整个 yml 文件看下来，并没有很多，但算是一个比较全面的 docker-compose 配置文件了，虽然没有用到所有的配置字段，触类旁通，再多的配置字段都能轻车熟路的解析吧，先一级一级的看，一级有 version services networks，通过以上，就可以定义出需要的结构体了：\n#[derive(Debug, Serialize, Deserialize)] struct DockerYaml { version: String, services: HashMap\u0026lt;String, ServiceCfg\u0026gt;, } 这里的 services 的类型用的是 HashMap，因为 services 名称是一个变量，而且数量不固定，比如还可以增加 mysql 服务，所以 services 是一个动态，services 里面又引入了 ServiceCfg 类型，现在继续看 services 下一级的配置字段，其中 image 是必须要存在的配置，那 ServiceCfg 结构体可以定义成：\n#[derive(Debug, Clone, Serialize, Deserialize)] struct ServiceCfg { image: String, } 好了，就这么简单，先写个 main 函数把代码跑起来看看吧！\nfn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error\u0026gt;\u0026gt; { let mut file = File::open(\u0026quot;docker-compose.yml\u0026quot;)?; // 打开文件 let mut contents = String::new(); // 创建一个字符串 file.read_to_string(\u0026amp;mut contents)?; // 读取文件内容到字符串缓冲区 // println!(\u0026quot;读取到的 YAML 内容:\\n{}\u0026quot;, contents); // 打印原始的YAML字符串 // 将 YAML 字符串反序列化为 DockerYaml 结构体 let docker_yaml: DockerYaml = serde_yaml::from_str(\u0026amp;contents)?; // 打印反序列化后的结构体 println!(\u0026quot;反序列化后的结构体: {:?}\u0026quot;, docker_yaml); // 读取出 services let services = \u0026amp;docker_yaml.services; for (serve, config) in services { println!(\u0026quot;services name: {}\u0026quot;, serve); println!(\u0026quot;services config: {:?}\u0026quot;, config); } Ok(()) } // 打印的内容： // 反序列化后的结构体: DockerYaml { version: \u0026quot;3.9\u0026quot;, services: {\u0026quot;nginx\u0026quot;: ServiceCfg { image: \u0026quot;nginx:latest\u0026quot; }, \u0026quot;redis\u0026quot;: ServiceCfg { image: \u0026quot;redis:latest\u0026quot; }} } // services name: nginx // services config: ServiceCfg { image: \u0026quot;nginx:latest\u0026quot; } // services name: redis // services config: ServiceCfg { image: \u0026quot;redis:latest\u0026quot; } 正常打印了，现在可以完善 ServiceCfg 这个结构体了\n2.动态字段解析 docker-compose 配置的 services 中，大部分配置都可选的，如果不配置，就会有个默认值，先不关心这个默认值是什么，但起码要实现一个不配置会有默认值的功能，带着疑问，先去写一下代码，\n把 ServiceCfg 结构体修改成以下的样子：\n#[derive(Debug, Clone, Serialize, Deserialize)] struct ServiceCfg { image: String, restart: String, } 只是添加了一个 restart 配置项，main 函数不变，cargo run 一下发现正常打印了如下：\n反序列化后的结构体: DockerYaml { version: \u0026quot;3.9\u0026quot;, services: {\u0026quot;nginx\u0026quot;: ServiceCfg { image: \u0026quot;nginx:latest\u0026quot;, restart: \u0026quot;always\u0026quot; }, \u0026quot;redis\u0026quot;: ServiceCfg { image: \u0026quot;redis:latest\u0026quot;, restart: \u0026quot;always\u0026quot; }} } services name: nginx services config: ServiceCfg { image: \u0026quot;nginx:latest\u0026quot;, restart: \u0026quot;always\u0026quot; } services name: redis services config: ServiceCfg { image: \u0026quot;redis:latest\u0026quot;, restart: \u0026quot;always\u0026quot; } restart 配置项正常读取到了，好像一切都很完美，但 restart 配置是个可选配置，那在 docker-compose.yml 文件中随便挑一个 restart 配置注释掉看看\nversion: \u0026quot;3.9\u0026quot; services: redis: image: redis:latest # restart: always privileged: false 再次运行 cargo run 就会发现报错了，报错很明显，缺少 restart 这个配置\nError: Error(\u0026quot;services.redis: missing field `restart`\u0026quot;, line: 4, column: 5) error: process didn't exit successfully: `target\\debug\\serde_yaml_test.exe` (exit code: 1) 要解决这个问题很简单，serde 提供了一个字段属性可以快速设置这个字段的默认值，\n#[serde(default)] 如果反序列化时该值不存在，使用Default::default()生成默认值\n在 ServiceCfg.restart 中加上就可以，所以把 ServiceCfg 结构体修改成以下的样子：\n#[derive(Debug, Clone, Serialize, Deserialize)] struct ServiceCfg { image: String, #[serde(default)] restart: String, } // 再次执行 cargo run 后会得到以下输出 // 反序列化后的结构体: DockerYaml { version: \u0026quot;3.9\u0026quot;, services: {\u0026quot;nginx\u0026quot;: ServiceCfg { image: \u0026quot;nginx:latest\u0026quot;, restart: \u0026quot;always\u0026quot; }, \u0026quot;redis\u0026quot;: ServiceCfg { image: \u0026quot;redis:latest\u0026quot;, restart: \u0026quot;\u0026quot; }} } // services name: nginx // services config: ServiceCfg { image: \u0026quot;nginx:latest\u0026quot;, restart: \u0026quot;always\u0026quot; } // services name: redis // services config: ServiceCfg { image: \u0026quot;redis:latest\u0026quot;, restart: \u0026quot;\u0026quot; } 自此，可选配置的默认值问题就解决了，但又有个问题，ports 和 volumes 该使用什么数据类型来承载呢，其实 yml 文件中，所有以 - 开头的，都表示同一级下有多个值，就那 redis 的 volumes 来说，他表示要映射本地多个数据卷到容器中，具体多少个？不知道，那这种结构是不是有点像可变长度的数组，在 rust 中最适合这种结构的类型是不是就是 Vec 了，基于此最终完善 ServiceCfg 结构体的内容如下：\n#[derive(Debug, Clone, Serialize, Deserialize)] struct ServiceCfg { image: String, #[serde(default)] restart: String, #[serde(default)] privileged: bool, #[serde(default)] ports: Vec\u0026lt;String\u0026gt;, #[serde(default)] volumes: Vec\u0026lt;String\u0026gt;, #[serde(default)] command: String, #[serde(default)] depends_on: Vec\u0026lt;String\u0026gt;, } 现在可以随意注释掉 services 中的除 image 配置外的所有配置了，而且解析也不会报错，也有默认值了，把 networks 配置也一并实现了吧\n#[derive(Debug, Serialize, Deserialize)] struct DockerYaml { version: String, services: HashMap\u0026lt;String, ServiceCfg\u0026gt;, #[serde(default)] networks: HashMap\u0026lt;String, NetworkCfg\u0026gt;, } #[derive(Debug, Clone, Serialize, Deserialize)] struct ServiceCfg { image: String, #[serde(default)] restart: String, #[serde(default)] privileged: bool, #[serde(default)] ports: Vec\u0026lt;String\u0026gt;, #[serde(default)] volumes: Vec\u0026lt;String\u0026gt;, #[serde(default)] command: String, #[serde(default)] depends_on: Vec\u0026lt;String\u0026gt;, } #[derive(Debug, Clone, Serialize, Deserialize)] struct NetworkCfg { #[serde(default)] driver: Option\u0026lt;String\u0026gt;, #[serde(default)] attachable: Option\u0026lt;bool\u0026gt;, } fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error\u0026gt;\u0026gt; { let mut file = File::open(\u0026quot;docker-compose.yml\u0026quot;)?; // 打开文件 let mut contents = String::new(); // 创建一个字符串 file.read_to_string(\u0026amp;mut contents)?; // 读取文件内容到字符串缓冲区 // println!(\u0026quot;读取到的 YAML 内容:\\n{}\u0026quot;, contents); // 打印原始的YAML字符串 // 将 YAML 字符串反序列化为 DockerYaml 结构体 let docker_yaml: DockerYaml = serde_yaml::from_str(\u0026amp;contents)?; // 打印反序列化后的结构体 println!(\u0026quot;反序列化后的结构体: {:?}\u0026quot;, docker_yaml); // 读取出 services let services = \u0026amp;docker_yaml.services; for (serve, config) in services { println!(\u0026quot;services name: {}\u0026quot;, serve); println!(\u0026quot;services config: {:?}\u0026quot;, config); } // 读取出 networks let networks = \u0026amp;docker_yaml.networks; for (serve, config) in networks { println!(\u0026quot;networks name: {}\u0026quot;, serve); println!(\u0026quot;networks config: {:?}\u0026quot;, config); } // 将数据结构序列化为 YAML 字符串 let yaml_string = serde_yaml::to_string(\u0026amp;docker_yaml)?; println!(\u0026quot;序列化为 YAML 字符串:\\n{}\u0026quot;, yaml_string); // 打印序列化后的 YAML 字符串 Ok(()) } 因为 networks 配置也是一个可选配置，所以在 DockerYaml 结构体中要加上 #[serde(default)]字段属性，至此，读取 yml 文件算是完成了，但看上面的 main 函数，把反序列化的结构体再转换为 yml 文件，就会有点点小问题，实际上上面代码执行完后会生成一个跟读取的 yml 文件不一样内容的 yml 字符串出来，如果期望读取的什么 yml 生成的 yml 也一模一样怎么办？\n3.序列化时剔除默认配置 需要可选字段在未设置时在反序列时有生成默认值，但在序列化时把默认值去除，可以使用 serde 的 #[serde(skip_serializing_if = \u0026quot;path\u0026quot;)] 调用一个函数来确定是否跳过序列化该字段。给定的函数必须可以作为fn(\u0026amp;T)-\u0026gt;bool调用，尽管它可能是T上的泛型。例如skip_serializing_if=\u0026quot;Option::is_none\u0026quot;如果值是 None，那么就会跳过。\n现在来改造一下上面的 ServiceCfg ：\n#[derive(Debug, Clone, Serialize, Deserialize)] struct ServiceCfg { image: String, #[serde(skip_serializing_if = \u0026quot;String::is_empty\u0026quot;, default)] restart: String, #[serde(skip_serializing_if = \u0026quot;Option::is_none\u0026quot;, default)] privileged: Option\u0026lt;bool\u0026gt;, #[serde(skip_serializing_if = \u0026quot;Vec::is_empty\u0026quot;, default)] ports: Vec\u0026lt;String\u0026gt;, #[serde(skip_serializing_if = \u0026quot;Vec::is_empty\u0026quot;, default)] volumes: Vec\u0026lt;String\u0026gt;, #[serde(skip_serializing_if = \u0026quot;String::is_empty\u0026quot;, default)] command: String, #[serde(skip_serializing_if = \u0026quot;Vec::is_empty\u0026quot;, default)] depends_on: Vec\u0026lt;String\u0026gt;, } 这里有个细节是 privileged 属性由原来的 bool 类型换成了 Option\u0026lt;bool\u0026gt;， 其中缘由就是 bool 类型不好做类型默认值判断， 像其他的 String，Vec，Option 都有对应的函数给 skip_serializing_if 做默认值判断，换成 Option 后，解析时如果遇到未配置时就会使用 None 代替原来的 bool 默认值，因为 Option 类型的默认值就是 None ，后面使用起来也是很方便的，实际上所有的可选字段配置都可以使用 Option 类型包起来，比如: depends_on : Option\u0026lt;Vec\u0026lt;String\u0026gt;\u0026gt;，只不过这样写后默认值就不是空的 Vec 了，而是 None，而值存在时就是 Some(Vec[]) 了。\n现在还剩一个问题，就是 networks 如果没有配置，但生成的 yml 也会默认带上 networks: {}，这个可以使用 HashMap::is_empty 来判断，\n#[derive(Debug, Serialize, Deserialize)] struct DockerYaml { version: String, services: HashMap\u0026lt;String, ServiceCfg\u0026gt;, #[serde(skip_serializing_if = \u0026quot;HashMap::is_empty\u0026quot;, default)] networks: HashMap\u0026lt;String, NetworkCfg\u0026gt;, } 那如果是自己定义的类型呢，难道要给自定义类型增加一个判断是否为空的方法吗？可以，但没必要，除非其他逻辑有用到，可以定义一个函数来判断类型是否为空，比如：\n#[derive(Debug, Serialize, Deserialize)] struct DockerYaml { version: String, services: HashMap\u0026lt;String, ServiceCfg\u0026gt;, #[serde(skip_serializing_if = \u0026quot;is_default\u0026quot;, default)] networks: HashMap\u0026lt;String, NetworkCfg\u0026gt;, } // 调用这个函数来确定是否跳过序列化该字段 fn is_default\u0026lt;T: Default + PartialEq\u0026gt;(v: \u0026amp;T) -\u0026gt; bool { v == \u0026amp;T::default() } // 因为泛型 T 在函数中用到比较运算，所以要给泛型添加 PartialEq 约束， // 用于判断是否是默认值，所以 T 要有 default 方法，故也要加上 Default 约束 // 其中 T 表示 HashMap，如果 HashMap 的泛型约束有 PartialEq， 那就表示 HashMap 里面 // 的类型也同样具有相应的约束，所以 NetworkCfg 也要实现 PartialEq trait, // 而 Default trait 是默认实现的，因为 NetworkCfg 里所有的成员都实现了 Default trait #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)] // 这行可以省略 Default struct NetworkCfg { #[serde(default)] driver: Option\u0026lt;String\u0026gt;, #[serde(default)] attachable: Option\u0026lt;bool\u0026gt;, } 五、总结 至此，解析 yml 文件算是大功告成了，当然这里只是介绍一小部分 serde 字段属性，但也可以应付大部分场景了，其他的比如字段别名，序列化时处理逻辑，反序列化时处理逻辑，就留在以后去探索吧。\n","permalink":"https://lorenwe.eu.org/posts/tech/rust%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%A7%A3%E6%9E%90yaml%E6%96%87%E4%BB%B6/","summary":"\u003ch3 id=\"一简介\"\u003e一、简介\u003c/h3\u003e\n\u003cp\u003eserde_yaml 是 Rust 语言中一个用于序列化和反序列化 YAML 数据的库。它以其高性能和灵活性而广受欢迎，特别适用于需要处理 YAML 配置文件的项目。在这篇博客中，我们将探讨 serde_yaml 的基本用法，并提供一些实用的示例代码。\u003c/p\u003e\n\u003ch3 id=\"二使用场景\"\u003e二、使用场景\u003c/h3\u003e\n\u003cp\u003eserde_yaml 常用于以下场景：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e配置管理：许多应用程序使用 YAML 文件来存储配置参数，serde_yaml 可以轻松解析这些文件。\u003c/li\u003e\n\u003cli\u003e数据交换：在系统之间传递数据时，YAML 格式因其可读性而常被选用。\u003c/li\u003e\n\u003cli\u003e文档生成：一些工具使用 YAML 来描述文档结构，serde_yaml 可以帮助生成和解析这些文档。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"三基本使用\"\u003e三、基本使用\u003c/h3\u003e\n\u003cp\u003e开始使用 serde_yaml 之前，先创建一个 serde_yaml_test 项目文件夹，在文件夹中使用 \u003ccode\u003ecargo init\u003c/code\u003e 初始化 rust 项目，然后在项目的 Cargo.toml 文件中添加依赖：\u003c/p\u003e","title":"Rust如何正确解析yaml文件"},{"content":"原文： Sizedness in Rust\n概述 Sized 其实是 Rust 中最重要的概念之一，可谓功成不居。它往往以微妙的形式与其他语言特性交织在一起，只有在形如 \u0026ldquo;x doesn\u0026rsquo;t have size known at compile time\u0026rdquo; 的错误信息中才会显露，这些错误信息对于每个 Rustacean 来说都太过熟悉了。在本文中，我们将探讨 Sized 的各种形式，包括固定大小类型、未定大小类型以及零大小类型，同时还将考察它们的用例、优势、痛点及相应解决方案。\n[注：本文的“宽度”通常指指针宽度，也就是机器字长。在 32 位系统中，1 个宽度的大小是 32 位，也就是 4 个字节；在 64 位系统中则是 8 个字节。2 个宽度也叫“胖指针”或“宽指针”。]\nSized 在 Rust 中，如果一个类型的字节大小可以在编译期确定，那么它就是 固定大小类型（sized type）。确定某类型的大小非常重要，只有这样才能在栈上为该类型的实例分配足够的空间。固定大小类型可以通过值或引用进行传递。如果一个类型的大小无法在编译期确定，那么它被称为 未定大小类型（unsized type） 或 动态大小类型（DST, Dynamically-Sized Type）。由于未定大小类型无法放置在栈上，因此它们只能通过引用进行传递。以下是一些固定大小和未定大小类型的示例：\nuse std::mem::size_of; fn main() { // 原生类型 assert_eq!(4, size_of::\u0026lt;i32\u0026gt;()); assert_eq!(8, size_of::\u0026lt;f64\u0026gt;()); // 元组 assert_eq!(8, size_of::\u0026lt;(i32, i32)\u0026gt;()); // 数组 assert_eq!(0, size_of::\u0026lt;[i32; 0]\u0026gt;()); assert_eq!(12, size_of::\u0026lt;[i32; 3]\u0026gt;()); struct Point { x: i32, y: i32, } // 结构体 assert_eq!(8, size_of::\u0026lt;Point\u0026gt;()); // 枚举 assert_eq!(8, size_of::\u0026lt;Option\u0026lt;i32\u0026gt;\u0026gt;()); // 获取指针宽度(即机器字长)， // 在 32 位系统上是 4 个字节 // 在 64 位系统上是 8 个字节 const WIDTH: usize = size_of::\u0026lt;\u0026amp;()\u0026gt;(); // 指向固定大小类型的指针占用 1 个宽度 assert_eq!(WIDTH, size_of::\u0026lt;\u0026amp;i32\u0026gt;()); assert_eq!(WIDTH, size_of::\u0026lt;\u0026amp;mut i32\u0026gt;()); assert_eq!(WIDTH, size_of::\u0026lt;Box\u0026lt;i32\u0026gt;\u0026gt;()); assert_eq!(WIDTH, size_of::\u0026lt;fn(i32) -\u0026gt; i32\u0026gt;()); const DOUBLE_WIDTH: usize = 2 * WIDTH; // 未定大小的结构体 struct Unsized { unsized_field: [i32], } // 指向未定大小类型的指针占用 2 个宽度 assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;\u0026amp;str\u0026gt;()); // 切片 assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;\u0026amp;[i32]\u0026gt;()); // 切片 assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;\u0026amp;dyn ToString\u0026gt;()); // trait 对象 assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;Box\u0026lt;dyn ToString\u0026gt;\u0026gt;()); // trait 对象 assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;\u0026amp;Unsized\u0026gt;()); // 自定义的未定大小类型 // 未定大小类型 size_of::\u0026lt;str\u0026gt;(); // 编译错误 size_of::\u0026lt;[i32]\u0026gt;(); // 编译错误 size_of::\u0026lt;dyn ToString\u0026gt;(); // 编译错误 size_of::\u0026lt;Unsized\u0026gt;(); // 编译错误 } 固定大小类型的大小显而易见：所有原生类型和指针都具有已知大小，而所有的结构体、元组、枚举和数组都是由原生类型、指针或其他嵌套的结构体、元组、枚举和数组组成的，因此可以递归地计算其字节总数，以及内存填充和对齐所需的额外字节。同样显而易见的是，未定大小类型的大小无法确定：切片可以包含任意数量的元素，因此它在运行期具有任意大小；而 trait 对象则可以由任意数量的结构体或枚举实现，因此在运行期也可以具有任意大小。\n专业提示\n在 Rust 中，指向动态大小数组视图的指针被称为切片（slice）。例如，\u0026amp;str 被称为 \u0026ldquo;字符串切片\u0026rdquo;，\u0026amp;[i32] 被称为 \u0026ldquo;i32 切片\u0026rdquo; 切片占用 2 个宽度，分别存储指向数组的指针和数组中元素的数量 trait 对象指针占用 2 个宽度，分别存储指向数据的指针和指向虚表（vtable）的指针 未定大小的结构体指针占用 2 个宽度，分别存储指向结构体数据的指针和结构体的大小 未定大小的结构体只能有一个未定大小的字段，并且它必须是结构体中最后一个字段 为了强化“未定大小类型占用 2 个宽度”的观点，此处通过带注释的代码示例，将数组与切片进行了比较。\nuse std::mem::size_of; const WIDTH: usize = size_of::\u0026lt;\u0026amp;()\u0026gt;(); const DOUBLE_WIDTH: usize = 2 * WIDTH; fn main() { // 类型中存储的数据长度 // [i32; 3] 表示存放三个 i32 的数组 let nums: \u0026amp;[i32; 3] = \u0026amp;[1, 2, 3]; // 1 个指针宽度 assert_eq!(WIDTH, size_of::\u0026lt;\u0026amp;[i32; 3]\u0026gt;()); let mut sum = 0; // 可以安全地迭代 nums // Rust 知道其确切有 3 个元素 for num in nums { sum += num; } assert_eq!(6, sum); // 未定大小强制转换，从 [i32; 3] 转为 [i32] // 数据长度现在存储在指针中 let nums: \u0026amp;[i32] = \u0026amp;[1, 2, 3]; // 需要 2 个指针宽度来同时存储数据长度 assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;\u0026amp;[i32]\u0026gt;()); let mut sum = 0; // 可以安全地迭代 nums // Rust 知道其确切有 3 个元素 for num in nums { sum += num; } assert_eq!(6, sum); } 以下是另一个有注释的代码示例，比较了结构体和 trait 对象的区别：\nuse std::mem::size_of; const WIDTH: usize = size_of::\u0026lt;\u0026amp;()\u0026gt;(); const DOUBLE_WIDTH: usize = 2 * WIDTH; trait Trait { fn print(\u0026amp;self); } struct Struct; struct Struct2; impl Trait for Struct { fn print(\u0026amp;self) { println!(\u0026quot;struct\u0026quot;); } } impl Trait for Struct2 { fn print(\u0026amp;self) { println!(\u0026quot;struct2\u0026quot;); } } fn print_struct(s: \u0026amp;Struct) { // 总是打印 \u0026quot;struct\u0026quot;，编译期即可知 s.print(); // 单宽度指针 assert_eq!(WIDTH, size_of::\u0026lt;\u0026amp;Struct\u0026gt;()); } fn print_struct2(s2: \u0026amp;Struct2) { // 总是打印 \u0026quot;struct2\u0026quot;，编译期即可知 s2.print(); // 单宽度指针 assert_eq!(WIDTH, size_of::\u0026lt;\u0026amp;Struct2\u0026gt;()); } fn print_trait(t: \u0026amp;dyn Trait) { // 打印 \u0026quot;struct\u0026quot; 还是 \u0026quot;struct2\u0026quot; ? 编译期不可知 t.print(); // Rust 需要在运行期检查指针以确定是使用 // Struct 还是 Struct2 的 \u0026quot;print\u0026quot; 实现， // 所以指针必须是双宽度的 assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;\u0026amp;dyn Trait\u0026gt;()); } fn main() { // 单宽度指针，指向数据 let s = \u0026amp;Struct; print_struct(s); // 打印 \u0026quot;struct\u0026quot; // 单宽度指针，指向数据 let s2 = \u0026amp;Struct2; print_struct2(s2); // 打印 \u0026quot;struct2\u0026quot; // 未定大小强制转换，从 Struct 到 dyn Trait // 双宽度指针，指向数据和 Struct 的虚表 let t: \u0026amp;dyn Trait = \u0026amp;Struct; print_trait(t); // 打印 \u0026quot;struct\u0026quot; // 未定大小强制转换，从 Struct2 到 dyn Trait // 双宽度指针，指向数据和 Struct2 的虚表 let t: \u0026amp;dyn Trait = \u0026amp;Struct2; print_trait(t); // 打印 \u0026quot;struct2\u0026quot; } 主要收获\n只有固定大小类型的实例可以放在栈上，也就是说，可以按值传递 未定大小类型的实例无法放在栈上，必须通过引用进行传递 指向未定大小类型的指针是双宽度的，因为除了指向数据之外，它们还有额外的信息要管理，用以跟踪数据的长度或者指向虚表 Sized Trait 在 Rust 中，Sized trait 属于自动 trait，同时也是一个标记 trait。\n自动 trait 是指在特定条件下自动为类型实现的 trait 。标记 trait 则用于表明类型具有某种特定属性，标记 trait 不包含任何 trait 项——像是方法、关联函数、关联常量或关联类型。所有自动 trait 都是标记 trait ，但不是所有标记 trait 都是自动 trait 。自动 trait 必须是标记 trait ，因为只有这样编译器才能为它们提供自动默认实现，如果某 trait 具有任何 trait 项，就无法再提供自动默认实现了。\n如果一个类型的所有成员都是 Sized 类型，那么该类型将自动获得 Sized 实现。“成员”的具体含义取决于容器类型，例如：结构体的字段，枚举的变体，数组的元素，元组的项等等。一旦某类型被标记为具有 Sized 实现，意味着它的字节大小在编译期便已知。\n其他自动标记 trait 的例子还有 Send 和 Sync。如果一个类型实现了 Send，则意味着该类型的值可以从一个线程传递到另一个线程。如果一个类型实现了 Sync，则意味着可以在多线程间使用共享引用共享其值。如果一个类型的所有成员都是 Send 和 Sync 类型，那么它将自动获得 Send 和 Sync 实现。Sized 有些特殊之处，与其他自动标记 trait 不同的是，它不可被取消。\n#![feature(negative_impls)] // 该类型是 Sized, Send 及 Sync struct Struct; // 取消 Send trait impl !Send for Struct {} // ✅ // 取消 Sync trait impl !Sync for Struct {} // ✅ // 不能取消 Sized impl !Sized for Struct {} // ❌ 这倒也合乎情理，毕竟我们可能出于一些原因不希望某类型被在线程之间传递或共享，然而很难想象出这种情景：希望编译器“忘记”某类型的大小，并将其视为一个未定大小的类型。这样做没有任何好处，只会使该类型变得更加难以处理。\n此外，非常谨慎地说，Sized 在技术上其实并不是一个自动 trait，因为它并没有使用 auto 关键字进行定义，然而编译器对它的特殊处理方式使其行为非常类似于自动 trait，因此在实践中将其视为自动 trait 是可行的。\n主要收获\nSized 是 “自动” 标记 trait 泛型中的 Sized 可能不易察觉：当编写泛型代码时，每个泛型类型参数默认都会自动绑定到 Sized trait 上。\n// 该泛型函数... fn func\u0026lt;T\u0026gt;(t: T) {} // ...去掉语法糖后... fn func\u0026lt;T: Sized\u0026gt;(t: T) {} // ...可以通过明确设置为 ?Sized 来取消它... fn func\u0026lt;T: ?Sized\u0026gt;(t: T) {} // ❌ // ...然而这将无法编译，毕竟它没有已知的大小。 // 因此我们必须将其放在指针后面... fn func\u0026lt;T: ?Sized\u0026gt;(t: \u0026amp;T) {} // ✅ fn func\u0026lt;T: ?Sized\u0026gt;(t: Box\u0026lt;T\u0026gt;) {} // ✅ 专业提示\n?Sized 可读作“可选大小的”或“可能具有大小的”，其被添加到类型参数的约束中，表示该类型既可以是固定大小，也可以是未定大小的 ?Sized 通常被称为“放宽约束”或“宽松约束”，因为它放宽了对类型参数的限制 ?Sized 是 Rust 中唯一的宽松约束 这个知识点很重要，为什么？这样说吧，每当使用泛型类型并将其置于指针后面时，我们几乎总是希望取消掉默认的 Sized 约束，以使函数在接受参数类型时更加灵活。另一方面，如果不取消掉默认的 Sized 约束，最终将会得到些令人困惑的编译错误信息。\n接下来参观一下我在 Rust 中编写的第一个泛型函数。我在 dbg! 宏稳定发布前便开始学习 Rust，那时打印调试值的唯一方法是每次都手动输入 println!(\u0026quot;{:?}\u0026quot;, some_value);，相当繁琐。因此，我决定编写这样一个 debug 辅助函数：\nuse std::fmt::Debug; fn debug\u0026lt;T: Debug\u0026gt;(t: T) { // T: Debug + Sized println!(\u0026quot;{:?}\u0026quot;, t); } fn main() { debug(\u0026quot;my str\u0026quot;); // T = \u0026amp;str, \u0026amp;str: Debug + Sized ✅ } 目前为止一切顺利，但是该函数会获取任何传递给它的值的所有权，这有点让人闹心，所以我将函数改为只接受引用作为参数：\nuse std::fmt::Debug; fn dbg\u0026lt;T: Debug\u0026gt;(t: \u0026amp;T) { // T: Debug + Sized println!(\u0026quot;{:?}\u0026quot;, t); } fn main() { dbg(\u0026quot;my str\u0026quot;); // \u0026amp;T = \u0026amp;str, T = str, str: Debug + !Sized ❌ } 这下报错了：\nerror[E0277]: the size for values of type `str` cannot be known at compilation time --\u0026gt; src/main.rs:8:9 | 3 | fn dbg\u0026lt;T: Debug\u0026gt;(t: \u0026amp;T) { | - required by this bound in `dbg` ... 8 | dbg(\u0026quot;my str\u0026quot;); | ^^^^^^^^ doesn't have a size known at compile-time | = help: the trait `std::marker::Sized` is not implemented for `str` = note: to learn more, visit \u0026lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\u0026gt; help: consider relaxing the implicit `Sized` restriction | 3 | fn dbg\u0026lt;T: Debug + ?Sized\u0026gt;(t: \u0026amp;T) { | 当我头一次看到这些错误信息时也是一脸懵逼。尽管函数接收的参数比之前更加严格了，但却出现了编译错误！到底发生了什么？\n上面的代码注释中我已略微透露了答案，但总的来说：在编译过程中，Rust 解析 T 为具体类型时会执行模式匹配。下面的表格可以帮助厘清该问题：\n类型 T \u0026amp;T \u0026amp;str T = \u0026amp;str T = str 类型 Sized str ❌ \u0026amp;str ✅ \u0026amp;\u0026amp;str ✅ 这便是为什么在将函数改为接收引用后，我不得不添加 ?Sized 约束以使函数按预期工作。下面是可以正常工作的函数：\nuse std::fmt::Debug; fn debug\u0026lt;T: Debug + ?Sized\u0026gt;(t: \u0026amp;T) { // T: Debug + ?Sized println!(\u0026quot;{:?}\u0026quot;, t); } fn main() { debug(\u0026quot;my str\u0026quot;); // \u0026amp;T = \u0026amp;str, T = str, str: Debug + !Sized ✅ } 主要收获\n所有的泛型类型参数默认情况下都会自动绑定为 Sized。 若有泛型函数，它接收一个指针后面的参数 T，诸如 \u0026amp;T、Box、Rc 等等，此时几乎总是希望使用 T: ?Sized 取消掉默认的 Sized 约束 未定大小类型 切片 最常见的切片类型是字符串切片 \u0026amp;str 和数组切片 \u0026amp;[T]。切片之好处在于许多其他类型可以自动转换为切片，利用切片和 Rust 的自动类型转换机制，我们可以编写出灵活的 API。\n强制类型转换可以发生在很多场景，但最显著的是在函数参数中以及方法调用时。值得关注的类型转换有两种，即 解引用强转（Deref Coercion） 和 未定大小类型强转（Unsized Coercion）。解引用强转是指使用解引用操作将 T 强制转换为 U，即 T: Deref\u0026lt;Target = U\u0026gt;，例如 String.deref() -\u0026gt; str。未定大小类型强转是指将 T 强制转换为 U，其中 T 是一个固定大小的类型，而 U 是一个未定大小的类型，即 T: Unsize\u0026lt;U\u0026gt;，例如 [i32; 3] -\u0026gt; [i32]。\ntrait Trait { fn method(\u0026amp;self) {} } impl Trait for str { // 现在可以使用以下类型调用 \u0026quot;method\u0026quot; 方法 // 1) str 或 // 2) String， 因为 String: Deref\u0026lt;Target = str\u0026gt; } impl\u0026lt;T\u0026gt; Trait for [T] { // 现在可以使用以下类型调用 \u0026quot;method\u0026quot; 方法 // 1) 任意 \u0026amp;[T] // 2) 任意 U 且 U: Deref\u0026lt;Target = [T]\u0026gt;， 比如 Vec\u0026lt;T\u0026gt; // 3) [T; N] ，N 为任意值, 因为 [T; N]: Unsize\u0026lt;[T]\u0026gt; } fn str_fun(s: \u0026amp;str) {} fn slice_fun\u0026lt;T\u0026gt;(s: \u0026amp;[T]) {} fn main() { let str_slice: \u0026amp;str = \u0026quot;str slice\u0026quot;; let string: String = \u0026quot;string\u0026quot;.to_owned(); // 函数参数 str_fun(str_slice); str_fun(\u0026amp;string); // 解引用强转 // 方法调用 str_slice.method(); string.method(); // 解引用强转 let slice: \u0026amp;[i32] = \u0026amp;[1]; let three_array: [i32; 3] = [1, 2, 3]; let five_array: [i32; 5] = [1, 2, 3, 4, 5]; let vec: Vec\u0026lt;i32\u0026gt; = vec![1]; // 函数参数 slice_fun(slice); slice_fun(\u0026amp;vec); // 解引用强转 slice_fun(\u0026amp;three_array); // 未定大小类型强转 slice_fun(\u0026amp;five_array); // 未定大小类型强转 // 方法调用 slice.method(); vec.method(); // 解引用强转 three_array.method(); // 未定大小类型强转 five_array.method(); // 未定大小类型强转 } 主要收获\n利用切片和 Rust 的自动类型转换可以编写灵活的 API Trait 对象 默认情况下，trait 是 ?Sized 的。代码：\ntrait Trait: ?Sized {} 将会抛出：\nerror: `?Trait` is not permitted in supertraits --\u0026gt; src/main.rs:1:14 | 1 | trait Trait: ?Sized {} | ^^^^^^ | = note: traits are `?Sized` by default 我们很快就会讨论为什么 trait 默认是 ?Sized 的，但首先需要思考一下 trait 是 ?Sized 的意义何在？将上面的示例展开：\ntrait Trait where Self: ?Sized {} 默认情况下，trait 允许 self 可能为一个未定大小类型。之前讲过，不能通过值传递未定大小类型，因而限制了 trait 中可定义的方法的类型。理论上讲，不可能编写一个以值传递 self 或返回 self 的方法，但令人惊讶的是，以下代码竟然可以编译通过：\ntrait Trait { fn method(self); // ✅ } 然而一旦开始尝试实现该方法，无论是通过提供默认实现，还是通过为未定大小类型实现该 trait，都将导致编译错误：\ntrait Trait { fn method(self) {} // ❌ } impl Trait for str { fn method(self) {} // ❌ } 抛出：\nerror[E0277]: the size for values of type `Self` cannot be known at compilation time --\u0026gt; src/lib.rs:2:15 | 2 | fn method(self) {} | ^^^^ doesn't have a size known at compile-time | = help: the trait `std::marker::Sized` is not implemented for `Self` = note: to learn more, visit \u0026lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\u0026gt; = note: all local variables must have a statically known size = help: unsized locals are gated as an unstable feature help: consider further restricting `Self` | 2 | fn method(self) where Self: std::marker::Sized {} | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error[E0277]: the size for values of type `str` cannot be known at compilation time --\u0026gt; src/lib.rs:6:15 | 6 | fn method(self) {} | ^^^^ doesn't have a size known at compile-time | = help: the trait `std::marker::Sized` is not implemented for `str` = note: to learn more, visit \u0026lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\u0026gt; = note: all local variables must have a statically known size = help: unsized locals are gated as an unstable feature 若是想通过值传递 self，可以通过显式地将 trait 约束为 Sized 来修复第一个错误：\ntrait Trait: Sized { fn method(self) {} // ✅ } impl Trait for str { // ❌ fn method(self) {} } 现在抛出：\nerror[E0277]: the size for values of type `str` cannot be known at compilation time --\u0026gt; src/lib.rs:7:6 | 1 | trait Trait: Sized { | ----- required by this bound in `Trait` ... 7 | impl Trait for str { | ^^^^^ doesn't have a size known at compile-time | = help: the trait `std::marker::Sized` is not implemented for `str` = note: to learn more, visit \u0026lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\u0026gt; 这倒可以理解，毕竟当我们将 trait 约束为 Sized 时，就意味着无法再为 str 等未定大小类型实现它。另一方面，如果真想为 str 实现该 trait 呢？解决方案是保持 trait 为 ?Sized，并通过引用来传递 self：\ntrait Trait { fn method(\u0026amp;self) {} // ✅ } impl Trait for str { fn method(\u0026amp;self) {} // ✅ } 与其将整个 trait 标记为 ?Sized 或 Sized，更精微准确的做法是将单个方法标记为 Sized，如下所示：\ntrait Trait { fn method(self) where Self: Sized {} } impl Trait for str {} // ✅!? fn main() { \u0026quot;str\u0026quot;.method(); // ❌ } 不可思议，Rust 编译了 impl Trait for str {}，没有发出任何警告！好在在未定大小类型上调用 method 时，它最终能捕获到该错误，一切正常。这一表现略显古怪，但它却为实现 trait 时提供了些灵活性——可以为未定大小类型实现具有 Sized 的方法，只要你别去调用这些 Sized 方法即可。\ntrait Trait { fn method(self) where Self: Sized {} fn method2(\u0026amp;self) {} } impl Trait for str {} // ✅ fn main() { // 别去调用 \u0026quot;method\u0026quot; 就没事儿 \u0026quot;str\u0026quot;.method2(); // ✅ } 现在回到最初的问题，为什么 trait 默认是 ?Sized 的？答案在于 trait 对象。trait 对象本质上是未定大小的，毕竟任何大小的类型都可以实现某个 trait 。因此，若 Trait: ?Sized，则只能为 dyn Trait 实现 Trait。用代码表示如下：\ntrait Trait: ?Sized {} // 上面是 **必须** 的 impl Trait for dyn Trait { // 此处已被编译器施法 } // 由于 `dyn Trait` 是未定大小的 // 现在我们可以在程序中使用 `dyn Trait` 了 fn function(t: \u0026amp;dyn Trait) {} // ✅ 如果尝试编译上面的程序，会得到以下错误：\nerror[E0371]: the object type `(dyn Trait + 'static)` automatically implements the trait `Trait` --\u0026gt; src/lib.rs:5:1 | 5 | impl Trait for dyn Trait { | ^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Trait + 'static)` automatically implements trait `Trait` 编译器告诫我们冷静下来，因为它会自动为 dyn Trait 提供 Trait 的实现。再次强调，由于 dyn Trait 是未定大小的，编译器只能在 Trait: ?Sized 的情况下提供这个实现。如果我们将 Trait 约束为 Sized，它就变成了 “对象不安全”（object unsafe），这意味着无法将实现了 Trait 的类型转换为 dyn Trait 的 trait 对象。下面的程序如预期一样编译失败：\ntrait Trait: Sized {} fn function(t: \u0026amp;dyn Trait) {} // ❌ 抛出：\nerror[E0038]: the trait `Trait` cannot be made into an object --\u0026gt; src/lib.rs:3:18 | 1 | trait Trait: Sized {} | ----- ----- ...because it requires `Self: Sized` | | | this trait cannot be made into an object... 2 | 3 | fn function(t: \u0026amp;dyn Trait) {} | ^^^^^^^^^^ the trait `Trait` cannot be made into an object 接下来尝试创建一个具有 Sized 方法的 ?Sized trait，并看看是否可以将其转换为 trait 对象：\ntrait Trait { fn method(self) where Self: Sized {} fn method2(\u0026amp;self) {} } fn function(arg: \u0026amp;dyn Trait) { // ✅ arg.method(); // ❌ arg.method2(); // ✅ } 正如之前看到的，只要我们不在 trait 对象上调用 Sized 方法，一切都没问题。\n主要收获\n默认情况下，所有 trait 都是 ?Sized 的 若 impl Trait for dyn Trait ，必须有 Trait: ?Sized 可以在各个方法上单独采用 Self: Sized 通过 Sized 约束的 trait 无法转换为 trait 对象 Trait 对象的限制 即使某 trait 是对象安全（object-safe）的，仍会存在一些和大小相关的边界情况，它们限制了可以转换为 trait 对象的类型以及 trait 对象可以表示的 trait 数量、类型。\n无法将未定大小类型转换为 trait 对象\nfn generic\u0026lt;T: ToString\u0026gt;(t: T) {} fn trait_object(t: \u0026amp;dyn ToString) {} fn main() { generic(String::from(\u0026quot;String\u0026quot;)); // ✅ generic(\u0026quot;str\u0026quot;); // ✅ trait_object(\u0026amp;String::from(\u0026quot;String\u0026quot;)); // ✅ - 未定大小类型强转 trait_object(\u0026quot;str\u0026quot;); // ❌ - 无法进行未定大小类型强转 } 抛出:\nerror[E0277]: the size for values of type `str` cannot be known at compilation time --\u0026gt; src/main.rs:8:18 | 8 | trait_object(\u0026quot;str\u0026quot;); | ^^^^^ doesn't have a size known at compile-time | = help: the trait `std::marker::Sized` is not implemented for `str` = note: to learn more, visit \u0026lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\u0026gt; = note: required for the cast to the object type `dyn std::string::ToString` 将 \u0026amp;String 传递给接收 \u0026amp;dyn ToString 的函数能够正常工作，这是因为强制类型转换。String 实现了 ToString，而我们可以通过未定大小强转将固定大小类型（如 String）转换为未定大小类型（如 dyn ToString）。str 也实现了 ToString，将 str 转换为 dyn ToString 也需要未定大小强转，但 str 已经是未定大小的了！那又怎能将一个已是未定大小的类型转换为另一个未定大小的类型呢？\n\u0026amp;str 指针是双宽的，分别存储了指向数据的指针和数据的长度。\u0026amp;dyn ToString 指针也是双宽的，存储了指向数据和指向虚表的指针。而将 \u0026amp;str 强制转换为 \u0026amp;dyn ToString 需要三个宽席的指针，用于存储指向数据的指针、数据的长度和指向虚表的指针。Rust 不支持三个宽度的指针，因此无法将未定大小类型转换为 trait 对象。\n上面两段以表格形式总结如下：\n类型 指向数据的指针 数据的长度 指向虚表的指针 总宽度 \u0026amp;String ✅ ❌ ❌ 1 ✅ \u0026amp;str ✅ ✅ ❌ 2 ✅ \u0026amp;String as \u0026amp;dyn ToString ✅ ❌ ✅ 2 ✅ \u0026amp;str as \u0026amp;dyn ToString ✅ ✅ ✅ 3 ❌ 无法创建多 trait 对象\ntrait Trait {} trait Trait2 {} fn function(t: \u0026amp;(dyn Trait + Trait2)) {} 抛出:\nerror[E0225]: only auto traits can be used as additional traits in a trait object --\u0026gt; src/lib.rs:4:30 | 4 | fn function(t: \u0026amp;(dyn Trait + Trait2)) {} | ----- ^^^^^^ | | | | | additional non-auto trait | | trait alias used in trait object type (additional use) | first non-auto trait | trait alias used in trait object type (first use) 记住，trait 对象的指针是双宽的：它存储着一个指向数据的指针和另一个指向虚表的指针，但此处有两个 trait，也就有两个虚表，这就需要将 \u0026amp;(dyn Trait + Trait2) 指针扩展为 3 个宽度（所以上述代码会报错）。而自动 trait（如 Sync 和 Send）是被允许的，毕竟它们没有方法，也就没有虚表。\n解决此问题的方法是使用另一个 trait 将虚表合并起来，如下所示：\ntrait Trait { fn method(\u0026amp;self) {} } trait Trait2 { fn method2(\u0026amp;self) {} } trait Trait3: Trait + Trait2 {} // 为同时实现了 Trait 和 Trait2 的类型 Trait3 自动提供默认实现 impl\u0026lt;T: Trait + Trait2\u0026gt; Trait3 for T {} // 将 `dyn Trait + Trait2` 改为 `dyn Trait3` fn function(t: \u0026amp;dyn Trait3) { t.method(); // ✅ t.method2(); // ✅ } 该变通方法的一个缺点是：Rust 不支持向上转换回 supertrait 类型。也就是说，对于 dyn Trait3，并不能将其用在需要 dyn Trait 或 dyn Trait2 的地方。以下程序无法编译：\ntrait Trait { fn method(\u0026amp;self) {} } trait Trait2 { fn method2(\u0026amp;self) {} } trait Trait3: Trait + Trait2 {} impl\u0026lt;T: Trait + Trait2\u0026gt; Trait3 for T {} struct Struct; impl Trait for Struct {} impl Trait2 for Struct {} fn takes_trait(t: \u0026amp;dyn Trait) {} fn takes_trait2(t: \u0026amp;dyn Trait2) {} fn main() { let t: \u0026amp;dyn Trait3 = \u0026amp;Struct; takes_trait(t); // ❌ takes_trait2(t); // ❌ } 抛出:\nerror[E0308]: mismatched types --\u0026gt; src/main.rs:22:17 | 22 | takes_trait(t); | ^ expected trait `Trait`, found trait `Trait3` | = note: expected reference `\u0026amp;dyn Trait` found reference `\u0026amp;dyn Trait3` error[E0308]: mismatched types --\u0026gt; src/main.rs:23:18 | 23 | takes_trait2(t); | ^ expected trait `Trait2`, found trait `Trait3` | = note: expected reference `\u0026amp;dyn Trait2` found reference `\u0026amp;dyn Trait3` 原因是在于尽管 dyn Trait3 包含了 dyn Trait 和 dyn Trait2 的所有方法，但它在某种意义上算作一个不同的类型，它与 dyn Trait 和 dyn Trait2 有着不同的虚表。再次变通的办法是添加显式的类型转换方法：\ntrait Trait {} trait Trait2 {} trait Trait3: Trait + Trait2 { fn as_trait(\u0026amp;self) -\u0026gt; \u0026amp;dyn Trait; fn as_trait2(\u0026amp;self) -\u0026gt; \u0026amp;dyn Trait2; } impl\u0026lt;T: Trait + Trait2\u0026gt; Trait3 for T { fn as_trait(\u0026amp;self) -\u0026gt; \u0026amp;dyn Trait { self } fn as_trait2(\u0026amp;self) -\u0026gt; \u0026amp;dyn Trait2 { self } } struct Struct; impl Trait for Struct {} impl Trait2 for Struct {} fn takes_trait(t: \u0026amp;dyn Trait) {} fn takes_trait2(t: \u0026amp;dyn Trait2) {} fn main() { let t: \u0026amp;dyn Trait3 = \u0026amp;Struct; takes_trait(t.as_trait()); // ✅ takes_trait2(t.as_trait2()); // ✅ } 这一解决办法简单又直接，而且看起来像是 Rust 编译器可以自动搞定的事情。Rust 在执行解引用和未定大小强转时表现得毫不犹豫，但又为什么没有向上游 trait 的强制转换呢？这个问题很好，答案也很熟悉：Rust 核心团队正在致力于其他优先级更高、影响更大的功能。行吧。\n主要收获\nRust 不支持超过 2 个宽度的指针，因此： 无法将未定大小类型转换为 trait 对象 无法创建多 trait 对象，但可以通过将多个 trait 合并为一个来解决该问题 用户自定义的未定大小类型 struct Unsized { unsized_field: [i32], } 可以通过给结构体添加一个未定大小的字段来定义一个未定大小的结构体。未定大小的结构体只能有一个未定大小的字段，而且该字段必须是结构体的最后一个字段。这样做是为了让编译器能够在编译时确定结构体中各个字段的起始偏移量，以便高效、快速地访问它们。此外，使用双宽度指针最多只能追踪一个未定大小的字段，毕竟更多的未定大小字段将需要更多的宽度。\n那么我们该如何实例化这个结构体呢？和其它未定大小类型一样，首先需要创建一个固定大小的版本，然后将其转换为未定大小的版本。然而，根据定义，Unsized 总是未定大小的，无法创建一个固定大小的版本！唯一的解决方法是将该结构体定义为泛型，这样它就可以同时存在固定大小和未定大小的版本：\nstruct MaybeSized\u0026lt;T: ?Sized\u0026gt; { maybe_sized: T, } fn main() { // 未定大小强转，从 MaybeSized\u0026lt;[i32; 3]\u0026gt; 至 MaybeSized\u0026lt;[i32]\u0026gt; let ms: \u0026amp;MaybeSized\u0026lt;[i32]\u0026gt; = \u0026amp;MaybeSized { maybe_sized: [1, 2, 3] }; } 它有何使用场景呢？实际上，并没有什么特别引人注目的使用场景:) 用户自定义的未定大小类型目前还是个不成熟的特性，其限制超过了其好处。此处提及只是为了本文完整性的考虑。\n小知识： std::ffi::OsStr和std::path::Path 是标准库中的两个未定大小类型的结构体，之前你可能使用过它们却没有意识到！\n主要收获\n用户自定义的未定大小类型目前还是个不成熟的特性，其限制超过了其好处。 零大小类型 零大小类型（ZST）一开始听起来很奇特，但其实它们在各种场景都被使用。\n单元类型（unit type） 最常见的零大小类型是单元类型：()。所有空代码块 {} 的求值结果均是 ()。若代码块非空但其最后一个表达式使用分号 ; 舍弃时，其求值结果也是 ()。例如：\nfn main() { let a: () = {}; let b: i32 = { 5 }; let c: () = { 5; }; } 默认情况下，没有显式指定返回类型的函数均返回 ()。\n// 带语法糖 fn function() {} // 去糖后 fn function() -\u0026gt; () {} 由于 () 占用零字节，所有 () 的实例都相同，这使得实现其 Default、PartialEq 及 Ord 非常简单：\nuse std::cmp::Ordering; impl Default for () { fn default() {} } impl PartialEq for () { fn eq(\u0026amp;self, _other: \u0026amp;()) -\u0026gt; bool { true } fn ne(\u0026amp;self, _other: \u0026amp;()) -\u0026gt; bool { false } } impl Ord for () { fn cmp(\u0026amp;self, _other: \u0026amp;()) -\u0026gt; Ordering { Ordering::Equal } } 编译器能够理解 () 为零大小，并优化与 () 实例相关的交互操作。例如，Vec\u0026lt;()\u0026gt; 不会进行任何堆分配，从 Vec 中 push 或 pop () 只会递增或递减其 len 字段：\nfn main() { // “存储”无限多个 () 所需的全部容量是：零容量 let mut vec: Vec\u0026lt;()\u0026gt; = Vec::with_capacity(0); // 不会导致堆分配或 vec 容量的变化 vec.push(()); // len++ vec.push(()); // len++ vec.push(()); // len++ vec.pop(); // len-- assert_eq!(2, vec.len()); } 上面的例子并没什么实际用处，但是，是否可以在某种情况下以一种有意义的方式利用上述理念呢？必然可以，比如可以将 Value 设置为 ()，从 HashMap\u0026lt;Key, Value\u0026gt; 中获得高效的 HashSet 实现，而这正是 Rust 标准库中 HashSet 的工作方式：\n// std::collections::HashSet pub struct HashSet\u0026lt;T\u0026gt; { map: HashMap\u0026lt;T, ()\u0026gt;, } 主要收获\n所有 ZST 实例互相都是等价的 Rust 编译器清楚如何优化与 ZST 的交互 单元结构体（unit struct） 单元结构体是指没有任何字段（成员变量）的结构体，例如：\nstruct Struct; 有一些特性使得单元结构体比 () 更具价值：\n可以在自定义的单元结构体上实现任意想要的 trait，Rust trait 所遵从的孤儿原则会阻止我们为 () 实现 trait，这是由于其在标准库中已经定义 可以根据程序上下文，为单元结构体赋予有意义的名称 单元结构体和所有结构体一样，默认情况下都是不可复制的，这在程序上下文中可能很重要。 Never 类型 Never 类型可算作第二常见的零大小类型（ZST）：!。它之所以被称为 never 类型，是因为其代表的计算永远不会解析成任何值。\n! 与 () 不同，它有一些有趣的特性：\n! 可以强制转换为任意其他类型 不可能创建 ! 的实例 第一个特性非常有用，使得我们能够这样便捷地使用宏：\n// 便于快速形成原型 fn example\u0026lt;T\u0026gt;(t: \u0026amp;[T]) -\u0026gt; Vec\u0026lt;T\u0026gt; { unimplemented!() // ! 强转为 Vec\u0026lt;T\u0026gt; } fn example2() -\u0026gt; i32 { // 可以看出此次调用 parse 永远不会失败 match \u0026quot;123\u0026quot;.parse::\u0026lt;i32\u0026gt;() { Ok(num) =\u0026gt; num, Err(_) =\u0026gt; unreachable!(), // ! 强转为 i32 } } fn example3(some_condition: bool) -\u0026gt; \u0026amp;'static str { if !some_condition { panic!() // ! 强转为 \u0026amp;str } else { \u0026quot;str\u0026quot; } } break、 continue 及 return 表达式也是 ! 类型:\nfn example() -\u0026gt; i32 { // 此处 x 可以设为任意类型， // 因为该代码块不返回任何值。 let x: String = { return 123 // ! 强转为 String }; } fn example2(nums: \u0026amp;[i32]) -\u0026gt; Vec\u0026lt;i32\u0026gt; { let mut filtered = Vec::new(); for num in nums { filtered.push( if *num \u0026lt; 0 { break // ! 强转为 i32 } else if *num % 2 == 0 { *num } else { continue // ! 强转为 i32 } ); } filtered } 第二个有趣的特性是：! 允许在类型层面上将某些状态标记为“不可能的”。以下面这个函数签名为例：\nfn function() -\u0026gt; Result\u0026lt;Success, Error\u0026gt;; 我们知道，如果函数成功返回，Result 将包含某个类型为 Success 的实例，如果出现错误，Result 将包含某个类型为 Error 的实例。接下来将其与该函数签名进行比较：\nfn function() -\u0026gt; Result\u0026lt;Success, !\u0026gt;; 我们知道，如果函数成功返回，Result 将包含某个类型为 Success 的实例，如果出现错误\u0026hellip;等等，它永远不会出错，因为无法创建 ! 的实例。根据上述函数签名可知该函数永远不会出错。那么下面这个函数签名呢：\nfn function() -\u0026gt; Result\u0026lt;!, Error\u0026gt;; 与之前相反，如果该函数返回，我们知道它一定是出错了，毕竟它不可能成功。\n前一个例子的实际应用是为 String 实现 FromStr，将 \u0026amp;str 转换为 String 不可能失败：\n#![feature(never_type)] use std::str::FromStr; impl FromStr for String { type Err = !; fn from_str(s: \u0026amp;str) -\u0026gt; Result\u0026lt;String, Self::Err\u0026gt; { Ok(String::from(s)) } } 后一个例子的实际应用是：运行无限循环的函数，比如一个响应客户端请求的服务器，除非发生错误否则永远不会返回：\n#![feature(never_type)] fn run_server() -\u0026gt; Result\u0026lt;!, ConnectionError\u0026gt; { loop { let (request, response) = get_request()?; let result = request.process(); response.send(result); } } 在 Rust 内部使用 never 类型是可行的，但在用户代码层面使用它仍被视为实验性质的，因此需要使用 never_type 特性标识。\n主要收获\n! 可以强制转换为其他任何类型 不能创建!的实例，但可以使用它在类型层面上标记某些不可能的状态 用户自定义的伪 Never 类型 尽管不能定义一个可以强制转换为任意其他类型的类型，但却可以定义一个无法创建实例的类型。例如，没有任何变体的枚举类型：\nenum Void {} 这样一来就可以从上一节的两个例子中移除 feature 标识，并使用稳定版的 Rust 来实现它们：\nenum Void {} // 示例 1 impl FromStr for String { type Err = Void; fn from_str(s: \u0026amp;str) -\u0026gt; Result\u0026lt;String, Self::Err\u0026gt; { Ok(String::from(s)) } } // 示例 2 fn run_server() -\u0026gt; Result\u0026lt;Void, ConnectionError\u0026gt; { loop { let (request, response) = get_request()?; let result = request.process(); response.send(result); } } 其实 Rust 标准库正是这么搞的，String 在实现 FromStr 时的 Err 类型用的是 std::convert::Infallible，其定义为：\npub enum Infallible {} PhantomData 第三个最常用的零大小类型（ZST）可能便是 PhantomData。PhantomData 是个零大小的标记结构体，包含它的结构体可以用它来“标记”其具有特定属性。它就像是 自动标记 trait （例如Sized、Send和Sync）的表亲，但由于它是一个结构体，使用方式会略有不同。详细解释 PhantomData 并探讨其所有用法已超出本文的范围，这里只简要介绍一个简单的例子。回想一下之前提到过的代码片段：\n#![feature(negative_impls)] // 该类型是 Send 及 Sync struct Struct; // 取消 Send trait impl !Send for Struct {} // 取消 Sync trait impl !Sync for Struct {} 很遗憾此处不得不使用 feature 标识，但能否只使用稳定版的 Rust 来实现相同的效果呢？我们已知，只有当一个类型的所有成员都是 Send 且 Sync 时，该类型才是 Send 且 Sync 的。因此可以向 Struct 添加一个 !Send 且 !Sync 的成员，例如 Rc\u0026lt;()\u0026gt;：\nuse std::rc::Rc; // 该类型不是 Send 或 Sync struct Struct { // 为每个实例增加 8 个字节 _not_send_or_sync: Rc\u0026lt;()\u0026gt;, } 以上方式并不理想，因为它会增加各 Struct 实例的大小，而且每次想要创建 Struct 时，还需要无中生有个 Rc\u0026lt;()\u0026gt; 出来。由于 PhantomData 是零大小类型（ZST），它解决了这俩问题：\nuse std::rc::Rc; use std::marker::PhantomData; type NotSendOrSyncPhantom = PhantomData\u0026lt;Rc\u0026lt;()\u0026gt;\u0026gt;; // 该类型不是 Send 或 Sync struct Struct { // 没有增加其实例的大小 _not_send_or_sync: NotSendOrSyncPhantom, } 主要收获\nPhantomData 是个零大小的标记结构体，包含它的结构体可以用它来“标记”其具有特定属性 结论 只有固定大小类型的实例可以放在栈上，也就是说，可以按值传递 未定大小类型的实例无法放在栈上，必须通过引用进行传递 指向未定大小类型的指针是双宽度的，因为除了指向数据之外，它们还有额外的信息要管理，用以跟踪数据的长度或者指向虚表 Sized 是 “自动” 标记 trait 所有的泛型类型参数默认情况下都会自动绑定为 Sized 若有泛型函数，它接收一个指针后面的参数 T，诸如 \u0026amp;T、Box、Rc 等等，此时几乎总是希望使用 T: ?Sized 取消掉默认的 Sized 约束 利用切片和 Rust 的自动类型转换可以编写灵活的 API 默认情况下，所有 trait 都是 ?Sized 的 若 impl Trait for dyn Trait ，必须有 Trait: ?Sized 可以在各个方法上单独采用 Self: Sized 通过 Sized 约束的 trait 无法转换为 trait 对象 Rust 不支持超过 2 个宽度的指针，因此： 无法将未定大小类型转换为 trait 对象 无法创建多 trait 对象，但可以通过将多个 trait 合并为一个来解决该问题 用户自定义的未定大小类型目前还是个不成熟的特性，其限制超过了其好处。 所有 ZST 实例互相都是等价的 Rust 编译器清楚如何优化与 ZST 的交互 ! 可以强制转换为其他任何类型 不能创建!的实例，但可以使用它在类型层面上标记某些不可能的状态 PhantomData 是个零大小的标记结构体，包含它的结构体可以用它来“标记”其具有特定属性 ","permalink":"https://lorenwe.eu.org/posts/tech/rust%E4%B8%AD%E7%9A%84sized/","summary":"\u003cp\u003e原文： \u003ca href=\"https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md\"\u003eSizedness in Rust\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"概述\"\u003e概述\u003c/h3\u003e\n\u003cp\u003eSized 其实是 Rust 中最重要的概念之一，可谓功成不居。它往往以微妙的形式与其他语言特性交织在一起，只有在形如 \u0026ldquo;x doesn\u0026rsquo;t have size known at compile time\u0026rdquo; 的错误信息中才会显露，这些错误信息对于每个 Rustacean 来说都太过熟悉了。在本文中，我们将探讨 Sized 的各种形式，包括固定大小类型、未定大小类型以及零大小类型，同时还将考察它们的用例、优势、痛点及相应解决方案。\u003c/p\u003e","title":"Rust 中的 Sized"},{"content":"字符串的类型大小和存储位置的概念定义及区分 在学习 Rust 的过程中，我们经常会遇到 Cannot know size until runtime: str 这样的报错，而大多数的解释都是搬运 Rust 官方文档的解释，这是由于 str 是动态大小类型 (Dynamic Sized Type，DST) ，因此编译器无法确定 str 类型的大小。然而给我们直观的感受是 \u0026ldquo;hello\u0026rdquo; 字面量只有 5 个字节，为什么在编译期间不能确定其大小呢？\n上述问题困扰了我很久，后来发现这是由于我对类型大小与值大小这两个概念搞混了。假设字符串字面量的类型是 str，那么考虑如下代码:\nlet hello: str = \u0026quot;hello\u0026quot;; // 假设代码，这里的代码编译不通过 let other: str = \u0026quot;other_hello\u0026quot;; let str_arr = vec![hello, other]; 会发现 hello 有 5 个字节，而 other 则有 11 个字节，并且 vec 中又要求所有成员的大小是一致的，那么 str 到底采用几个字节？这就解释了为什么 str 是动态大小类型。\n同时还有一个比较容易混淆的点，str 是动态大小类型，但是我们经常提到 str 字符串的长度是固定的，比较奇怪的点在于既然 str 是动态大小类型，为什么其长度又是固定的呢？这个问题其实和上一个问题一样，我们说 str 字符串的长度固定，指的是其具体的字符串字面量的值是不可变的；而动态大小类型，则指的是类型大小不确定 。\n由于变量是分配在 stack 上，而 stack上 类型的大小必须固定，因此 Rust 中为了能够使得变量绑定字符串，引入了字符串切片类型 \u0026amp;str。需要注意的是 \u0026amp;str 是一种类型，可以理解为 str 的引用类型。\u0026amp;str 类型由两部分构成: “指针和长度”，这两者长度都是固定的，因此 \u0026amp;str 类型可以存储在 stack 上。\n需要注意的是\u0026amp;str类型指向的数据并不一定分配在heap上，它可以在如下存储区域:\n静态存储区: 字符串字面量 \u0026ldquo;hello\u0026rdquo; 是 \u0026amp;\u0026lsquo;static str 类型，这部分数据直接硬编码到程序编译的二进制文件中 Heap 分配: 由 String 类型字符串 s 的切片生成 s[1..] Stack 分配: 对于如下分配到栈上的字节数组，可以将其转换为 \u0026amp;str 类型的字符串: use std::str; let x: \u0026amp;[u8] = \u0026amp;[b'a', b'b', b'c']; let stack_str: \u0026amp;str = str::from_utf8(x).unwrap(); 总结下来Rust中字符串的内存模型为下图这种:\n在 rust 中，类型大小和类型数据是分开的，换个说法就是 相同的类型，不同的数据，他们的类型大小是相同的，举个栗子：let a: i32 = 1; let b: i32 = 2; a 和 b 的类型大小都是 4 字节，和具体保存的数据没有关系\n在这种 let s: \u0026amp;str = \u0026quot;hello\u0026quot;; 代码中，往往会先入为主的认为 s 的类型大小是固定的，其实是错的，因该是 s 引用所指向的数据是固定不变的了，所以 s 指向的具体数据的大小是 5，注意区分 这里说的是数据大小的， 而实际项目中，没有办法创建出 str 类型的变量，当然不严谨的说 str 这个类型名称看起来就是给 字符串类型 用的，那字符串肯定不可能是固定大小的，所以 str 是动态大小类型，变量要在 stack 中保存，在 stack 中申请内存的前提条件是必须要知道类型大小，所以要声明一个 str 类型的变量，只能通过 \u0026amp;str 引用的方式来声明，因为引用是一个胖指针，类型大小是固定的\n","permalink":"https://lorenwe.eu.org/posts/tech/%E7%90%86%E8%A7%A3rust%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84strstr%E4%B8%8Estring%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"\u003ch3 id=\"字符串的类型大小和存储位置的概念定义及区分\"\u003e字符串的类型大小和存储位置的概念定义及区分\u003c/h3\u003e\n\u003cp\u003e在学习 Rust 的过程中，我们经常会遇到 Cannot know size until runtime: str 这样的报错，而大多数的解释都是搬运 Rust 官方文档的解释，这是由于 \u003cstrong\u003estr 是动态大小类型 (Dynamic Sized Type，DST) ，因此编译器无法确定 str 类型的大小\u003c/strong\u003e。然而给我们直观的感受是 \u0026ldquo;hello\u0026rdquo; 字面量只有 5 个字节，为什么在编译期间不能确定其大小呢？\u003c/p\u003e\n\u003cp\u003e上述问题困扰了我很久，后来发现这是由于我对\u003cstrong\u003e类型大小\u003c/strong\u003e与\u003cstrong\u003e值大小\u003c/strong\u003e这两个概念搞混了。假设字符串字面量的类型是 str，那么考虑如下代码:\u003c/p\u003e","title":"理解 Rust 中字符串的 str, \u0026str 与 String 类型的区别"},{"content":"由于现在 docker Desktop 默认使用 WSL 2 来运行，而不是以前的 Hyper-V。 所以 在win10上安装 docker Desktop时没有存储路径选择，而是直接默认安装到了系统 C盘，这样后续使用一些镜像后，日积月累C盘空间会越来越小。\n镜像文件位置是在C盘下的用户名下的\\AppData\\Local\\Docker\\wsl 例如我的保存位置是： C:\\Users\\Admin\\AppData\\Local\\Docker\\wsl\n默认情况下，Docker Desktop for Window会创建如下两个发行版（distro）：\ndocker-desktop docker-desktop-data 如果访问 %LOCALAPPDATA%/Docker/wsl 目录，就可以看到两个文件夹（data和distro），同时每个文件夹中都会有一个vhdx文件，而且这两个文件夹的占用空间会非常的大。 %LOCALAPPDATA% 就是当前登录用户的AppData\\Local目录， 假设当前登录的用户为Admin，那么这个目录就是 C:\\User\\Admin\\AppData\\Local\\Docker\\wsl\ndata/ext4.vhdx 是被 docker-desktop-data 发行版使用 distro/ext4.vhdx 是被 docker-desktop 发行版使用\ndocker-desktop-data 是被用来存储docker images 以及相关的数据。因此，它的大小会随着使用逐步增长，因此导致系统盘空间不足。 vhdx文件最大支持256G，超出这个大小将会出错。参见：官方说明\n一：将镜像导出 罗列出现在在使用WSL的。在CMD命令窗口执行 wsl \u0026ndash;list -v 假设你当前已经正常运行了 docker Desktop ，此时你会看到类似以下情况\nC:\\Users\\Admin\u0026gt;wsl -l --all -v NAME STATE VERSION * docker-desktop-data Running 2 docker-desktop Running 2 可能你的会有所不同，比如多了一个 Ubuntu Running 2,这个是你安装wsl2.0时默认安装的linux发行版，因为我不需要Linux环境，而安装Docker Desktop for Window时会自动安装 docker-desktop-data 和 docker-desktop 这两个docker专用发行版，所以我安装好wsl2.0后就把这个 Ubuntu 删除了\n现在打开 Docker Desktop 软件面板，先把所有的正在运行的容器全部停止，然后在电桌面的右下角点击 Docker Desktop 图标退出当前应用\n关闭WSL，执行命令 wsl --shutdown\n再次查看 当前WSL运行情况。使用的命令还是：wsl \u0026ndash;list -v.我们可以看到 STATE都已经是Stopped的了。\nC:\\Users\\Admin\u0026gt;wsl -l --all -v NAME STATE VERSION * docker-desktop-data Stopped 2 docker-desktop Stopped 2 导出镜像并压缩为tar.注意：导出的路径要提前创建好，不然执行命令会报错的。执行命令公式： wsl --export docker-desktop-data \u0026lt;导出后存放的文件路径\u0026gt;\n我提前创建好了保存文件位置，并且创建好镜像文件生成位置，也就是ext4.vhdx文件位置 为保证可读性，我创建的和原来的文件夹基本一致\nD:\\DockerData\\wsl // 导出文件保存位置 D:\\DockerData\\wsl\\data // docker-desktop-data镜像文件位置 D:\\DockerData\\wsl\\distro // docker-desktop镜像文件位置 所以我导出doceker-desktop、docker-desktop-data 命令如下：\nwsl --export docker-desktop D:\\DockerData\\wsl\\docker-desktop.tar wsl --export docker-desktop-data D:\\DockerData\\wsl\\docker-desktop-data.tar 如果有Ubuntu和上面类似方式导出就行 如果文件比较大的话，导出需要耗费一些时间。耐心等待导出完成即可 导出完成后，我的文件目录结构如下\n二：注销原来的docker镜像 使用命令公式：\nwsl --unregister \u0026lt;需要注销的名称\u0026gt;\n我的注销命令为：\n#注销原来的 Docker 镜像 #wsl --unregister Ubuntu 需要的可以注销 wsl --unregister docker-desktop-data wsl --unregister docker-desktop C:\\Users\\Admin\u0026gt;wsl --unregister docker-desktop-data 正在注销。 操作成功完成。 C:\\Users\\Admin\u0026gt;wsl --unregister docker-desktop 正在注销。 操作成功完成。 三条命令都执行完成之后，就注销了。注销之后，再去看C盘空间，此时就能看到空间已经释放出来了\n三：将导出的Docker镜像在导入到wsl,并设置挂载的文件目录 使用的命令公式为： wsl \u0026ndash;import \u0026lt;分配的名字\u0026gt; \u0026lt;本地保存路径\u0026gt;\u0026lt;文件名\u0026gt;\n套用公式，可以得到我需要导入的两条命令:\nwsl --import docker-desktop D:\\DockerData\\wsl\\distro D:\\DockerData\\wsl\\docker-desktop.tar wsl --import docker-desktop-data D:\\DockerData\\wsl\\data D:\\DockerData\\wsl\\docker-desktop-data.tar 执行完成之后，我们使用wsl \u0026ndash;list -v，查看是否成功。如下：\nC:\\Users\\Admin\u0026gt;wsl --list -v NAME STATE VERSION * docker-desktop Stopped 2 docker-desktop-data Stopped 2 可以看到，都已经导入成功。接下来，启动 Docker Desktop 即可。\n","permalink":"https://lorenwe.eu.org/posts/tech/%E5%9C%A8windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85dockerdesktop%E5%90%8E%E8%BF%81%E7%A7%BB%E9%95%9C%E5%83%8F%E4%BD%8D%E7%BD%AE/","summary":"\u003cp\u003e由于现在 docker Desktop 默认使用 WSL 2 来运行，而不是以前的 Hyper-V。\n所以 在win10上安装 docker Desktop时没有存储路径选择，而是直接默认安装到了系统 C盘，这样后续使用一些镜像后，日积月累C盘空间会越来越小。\u003c/p\u003e\n\u003cp\u003e镜像文件位置是在C盘下的用户名下的\\AppData\\Local\\Docker\\wsl\n例如我的保存位置是：\n\u003ccode\u003e C:\\Users\\Admin\\AppData\\Local\\Docker\\wsl\u003c/code\u003e\u003c/p\u003e","title":"在windows系统下安装DockerDesktop后迁移镜像位置"},{"content":"New_life\n","permalink":"https://lorenwe.eu.org/posts/life/new_life/","summary":"\u003cp\u003eNew_life\u003c/p\u003e","title":"New_life"},{"content":"创建代码仓库 首先创建 GitHub Pages 站点。该仓库可见性必须是 Public。\n另外创建一个仓库用来存放 Hugo 的源文件，名称随意，这里我的仓库名叫 blogs。建议将仓库可见性设置成 Private 以保护好文章 .md 文件。\n创建完毕后账户下将存在以下两个代码仓库：\n公有仓库：\nhttps://github.com/lorenwe/lorenwe.github.io\n私有仓库：\nhttps://github.com/lorenwe/blogs\n创建 Workflow 配置 在 blogs 仓库下新建 .github/workflows/deploy.yml 文件。内容如下：\nname: deploy on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Check out source uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026quot;latest\u0026quot; extended: true # 设置是否需要 extended 版本 - name: Fetch Hugo Themes # Fetch Hugo themes run: git submodule update --init --recursive - name: Build run: hugo --minify - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.DEPLOY_TOKEN }} # 另外还支持 github_token 和 personal_token external_repository: lorenwe/lorenwe.github.io # 修改为你的 GitHub Pages 仓库 publish_branch: main publish_dir: ./public keep_files: false cname: lorenwe.eu.org # 如果使用自定义域名，还需要添加下面一行配置 设置 SSH Key GitHub Pages action 支持三种身份验证方式：\ndeploy_key github_token personal_token 此处使用 deploy_key 方式。\n执行命令创建 SSH Key：ssh-keygen -t rsa -b 4096 -C \u0026quot;$(git config user.email)\u0026quot; -f gh-pages -N \u0026quot;\u0026quot;\nAdmin@DESKTOP-0O5ASOH MINGW64 ~/Desktop/blogs (main) $ ssh-keygen -t rsa -b 4096 -C \u0026quot;$(git config user.email)\u0026quot; -f gh-pages -N \u0026quot;\u0026quot; Generating public/private rsa key pair. Your identification has been saved in gh-pages Your public key has been saved in gh-pages.pub The key fingerprint is: SHA256:hXyduwgFN52vCsct9UUPVeXOiBZ+SZAcc26/KgL9Om0 lorenwe@163.com The key's randomart image is: +---[RSA 4096]----+ | . oo++..*| | . + o=*...| | o + +.+oo| | + ..*.*o| | S. o=o+.+| | ..o+ooo. .| | .o+o. . | | o.E . | | .= .. | +----[SHA256]-----+ 该命令会在当前命令行所在目录下生成两个密钥对文件 gh-pages 和 gh-pages.pub, 如果在 Windows 系统下运行该命令，要将命令中的 $(git config user.email) 替换成你的邮箱地址。\n先为GitHub Pages 站点仓库设置公钥，访问如下地址设置 Public key：\nhttps://github.com/lorenwe/lorenwe.github.io/settings/keys/new\n表单中的 Title 随意填写，将刚才生成的 gh-pages.pub 文件内容填入 Key 中，勾选 Allow write access，点击 Add key 按钮保存。如图：\n添加完成后的结果：\n再为文章源码仓库设置私钥，访问如下地址设置 Private key：\nhttps://github.com/lorenwe/blogs/settings/secrets/actions/new\n表单中的 Name 填入 DEPLOY_TOKEN，将刚才生成的 gh-pages 文件内容填入 Secret 中，点击 Add secret 按钮保存。\n添加完成后的结果：\n执行 GitHub Actions 将 blogs 仓库的代码提交并推送到 GitHub，会自动触发 GitHub Actions 执行。可以访问如下网址来查看 Workflows 是否执行成功：\nhttps://github.com/lorenwe/blogs/actions\n等待 workflow 执行完毕，静态站点就算是发布成功了。\n注：文章内所有 GitHub 链接都要替换成自己的仓库链接，例如：\nhttps://github.com/\u0026lt;YourName\u0026gt;/\u0026lt;YourName\u0026gt;.github.io\nhttps://github.com/\u0026lt;YourName\u0026gt;/blogs\n","permalink":"https://lorenwe.eu.org/posts/tech/%E4%BD%BF%E7%94%A8githubactions%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E7%AB%99%E7%82%B9/","summary":"\u003ch3 id=\"创建代码仓库\"\u003e创建代码仓库\u003c/h3\u003e\n\u003cp\u003e首先创建 GitHub Pages 站点。该仓库可见性必须是 Public。\u003c/p\u003e\n\u003cp\u003e另外创建一个仓库用来存放 Hugo 的源文件，名称随意，这里我的仓库名叫 blogs。建议将仓库可见性设置成 Private 以保护好文章 .md 文件。\u003c/p\u003e\n\u003cp\u003e创建完毕后账户下将存在以下两个代码仓库：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e公有仓库：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehttps://github.com/lorenwe/lorenwe.github.io\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e私有仓库：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehttps://github.com/lorenwe/blogs\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"创建-workflow-配置\"\u003e创建 Workflow 配置\u003c/h3\u003e\n\u003cp\u003e在 blogs 仓库下新建 .github/workflows/deploy.yml 文件。内容如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003ename: deploy\non:\n  push:\n    branches:\n      - main\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Check out source\n        uses: actions/checkout@v2\n        with:\n          submodules: true\n          fetch-depth: 0\n\n      - name: Setup hugo\n        uses: peaceiris/actions-hugo@v2\n        with:\n          hugo-version: \u0026quot;latest\u0026quot;\n          extended: true # 设置是否需要 extended 版本\n          \n      - name: Fetch Hugo Themes  # Fetch Hugo themes\n        run: git submodule update --init --recursive\n\n      - name: Build\n        run: hugo --minify\n\n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.DEPLOY_TOKEN }} # 另外还支持 github_token 和 personal_token\n          external_repository: lorenwe/lorenwe.github.io # 修改为你的 GitHub Pages 仓库\n          publish_branch: main\n          publish_dir: ./public\n          keep_files: false\n          cname: lorenwe.eu.org # 如果使用自定义域名，还需要添加下面一行配置\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"设置-ssh-key\"\u003e设置 SSH Key\u003c/h3\u003e\n\u003cp\u003eGitHub Pages action 支持三种身份验证方式：\u003c/p\u003e","title":"使用 GitHub Actions 自动部署 Hugo 站点"},{"content":"在 GitHub 上可以找到本教程的源码。\n衡量成功的标准 确保我们对代码有改进的唯一方法是测试一个不好的情况，然后将我们修复之后的测量与另一个进行比较。换句话说，除非我们知道“解决方案”对我们有多大的帮助（如果有的话），否则我们不知道它是否真的是一个解决方案。\n这里有两个我们可以关系的衡量标准。首先是CPU使用率。我们要处理的进程有多快或多慢？第二是内存使用情况。脚本执行时需要多少内存？这两个通常是成反比的 - 这意味着我们可以以CPU使用率为代价来降低内存使用，反之亦然。\n在一个异步执行模型（如多进程或多线程的PHP应用程序）中，CPU和内存的使用率是很重要的考量因素。在传统的PHP架构中，当任何一个值达到服务器的极限时，这些通常都会成为问题。\n测量PHP内的CPU使用率是不切实际的。如果这是你要关注的领域，请考虑在Ubuntu或MacOS上使用类似top的工具。对于Windows，请考虑使用Linux子系统，以便在Ubuntu中使用top。\n为了本教程的目的，我们将测量内存使用情况。我们将看看在“传统”的脚本中使用了多少内存。我们将执行一些优化策略并对其进行度量。最后，我希望你能够做出一个有经验的选择。 我们查看内存使用多少的方法是：\n// formatBytes is taken from the php.net documentation memory_get_peak_usage(); function formatBytes($bytes, $precision = 2) { $units = array(\u0026quot;b\u0026quot;, \u0026quot;kb\u0026quot;, \u0026quot;mb\u0026quot;, \u0026quot;gb\u0026quot;, \u0026quot;tb\u0026quot;); $bytes = max($bytes, 0); $pow = floor(($bytes ? log($bytes) : 0) / log(1024)); $pow = min($pow, count($units) - 1); $bytes /= (1 \u0026lt;\u0026lt; (10 * $pow)); return round($bytes, $precision) . \u0026quot; \u0026quot; . $units[$pow]; } 我们将在脚本的最后使用这些函数，以便我们能够看到哪个脚本一次使用最大的内存。\n我们的选择是什么？ 这里有很多方法可以有效地读取文件。但是也有两种我们可能使用它们的情况。我们想要同时读取和处理所有数据，输出处理过的数据或根据我们所读取的内容执行其他操作。我们也可能想要转换一个数据流，而不需要真正访问的数据。 让我们设想一下，对于第一种情况，我们希望读取一个文件，并且每10,000行创建一个独立排队的处理作业。我们需要在内存中保留至少10000行，并将它们传递给排队的工作管理器（无论采取何种形式）。 对于第二种情况，我们假设我们想要压缩一个特别大的API响应的内容。我们不在乎它的内容是什么，但我们需要确保它是以压缩形式备份的。 在这两种情况下，如果我们需要读取大文件，首先，我们需要知道数据是什么。第二，我们并不在乎数据是什么。让我们来探索这些选择吧\u0026hellip;\n逐行读取文件 有许多操作文件的函数，我们把部分结合到一个简单的文件阅读器中(封装为一个方法)：\n// from memory.php function formatBytes($bytes, $precision = 2) { $units = array(\u0026quot;b\u0026quot;, \u0026quot;kb\u0026quot;, \u0026quot;mb\u0026quot;, \u0026quot;gb\u0026quot;, \u0026quot;tb\u0026quot;); $bytes = max($bytes, 0); $pow = floor(($bytes ? log($bytes) : 0) / log(1024)); $pow = min($pow, count($units) - 1); $bytes /= (1 \u0026lt;\u0026lt; (10 * $pow)); return round($bytes, $precision) . \u0026quot; \u0026quot; . $units[$pow]; } print formatBytes(memory_get_peak_usage()); // from reading-files-line-by-line-1.php function readTheFile($path) { $lines = []; $handle = fopen($path, \u0026quot;r\u0026quot;); while(!feof($handle)) { $lines[] = trim(fgets($handle)); } fclose($handle); return $lines; } readTheFile(\u0026quot;shakespeare.txt\u0026quot;); require \u0026quot;memory.php\u0026quot;; 我们读取一个文本文件为莎士比亚全集。文件大小为5.5MB，内存占用峰值为12.8MB。现在让我们用一个生成器来读取每一行：\n// from reading-files-line-by-line-2.php function readTheFile($path) { $handle = fopen($path, \u0026quot;r\u0026quot;); while(!feof($handle)) { yield trim(fgets($handle)); } fclose($handle); } readTheFile(\u0026quot;shakespeare.txt\u0026quot;); require \u0026quot;memory.php\u0026quot;; 文本文件大小不变，但内存使用峰值只是393KB。即使我们能把读取到的数据做一些事情也并不意味着什么。也许我们可以在看到两条空白时把文档分割成块，像这样：\n// from reading-files-line-by-line-3.php $iterator = readTheFile(\u0026quot;shakespeare.txt\u0026quot;); $buffer = \u0026quot;\u0026quot;; foreach ($iterator as $iteration) { preg_match(\u0026quot;/\\n{3}/\u0026quot;, $buffer, $matches); if (count($matches)) { print \u0026quot;.\u0026quot;; $buffer = \u0026quot;\u0026quot;; } else { $buffer .= $iteration . PHP_EOL; } } require \u0026quot;memory.php\u0026quot;; 猜到我们使用了多少内存吗？我们把文档分割为1216块，仍然只使用了459KB的内存，这是否让你惊讶？考虑到生成器的性质，我们使用的最多内存是使用在迭代中我们需要存储的最大文本块。在本例中，最大的块为101985字符。\n我已经撰写了使用生成器提示性能和Nikita Popov的迭代器库，如果你感兴趣就去看看吧！\n生成器还有其它用途，但是最明显的好处就是高性能读取大文件。如果我们需要处理这些数据，生成器可能是最好的方法。\n管道间的文件 在我们不需要处理数据的情况下，我们可以把文件数据传递到另一个文件。通常被称为管道（大概是因为我们看不到除了两端的管子里面，当然，它也是不透明的），我们可以通过使用流方法实现。让我们先写一个脚本从一个文件传到另一个文件。这样我们可以测量内存的占用情况：\n// from piping-files-1.php file_put_contents( \u0026quot;piping-files-1.txt\u0026quot;, file_get_contents(\u0026quot;shakespeare.txt\u0026quot;) ); require \u0026quot;memory.php\u0026quot;; 不出所料，这个脚本使用更多的内存来进行文本文件复制。这是因为它读取(和保留)文件内容在内存中，直到它被写到新文件中。对于小文件这种方法也许没问题。当为更大的文件时，就捉襟见肘了…\n让我们尝试用流(管道)来传送一个文件到另一个：\n// from piping-files-2.php $handle1 = fopen(\u0026quot;shakespeare.txt\u0026quot;, \u0026quot;r\u0026quot;); $handle2 = fopen(\u0026quot;piping-files-2.txt\u0026quot;, \u0026quot;w\u0026quot;); stream_copy_to_stream($handle1, $handle2); fclose($handle1); fclose($handle2); require \u0026quot;memory.php\u0026quot;; 这段代码稍微有点陌生。我们打开了两文件的句柄，第一个是只读模式，第二个是只写模式，然后我们从第一个复制到第二个中。最后我们关闭了它，也许使你惊讶，内存只占用了393KB\n这似乎很熟悉。像代码生成器在存储它读到的每一行代码？那是因为第二个参数fgets规定了每行读多少个字节（默认值是-1或者直到下一行为止）。\n第三个参数stream_copy_to_stream和第二个参数是同一类参数（默认值相同），stream_copy_to_stream一次从一个数据流里读一行，同时写到另一个数据流里。它跳过生成器只有一个值的部分（因为我们不需要这个值）。\n这篇文章对于我们来说可能是没用的，所以让我们想一些我们可能会用到的例子。假设我们想从我们的CDN中输出一张图片，作为一种重定向的路由应用程序。我们可以参照下边的代码来实现它：\n// from piping-files-3.php file_put_contents( \u0026quot;piping-files-3.jpeg\u0026quot;, file_get_contents( \u0026quot;https://github.com/assertchris/uploads/raw/master/rick.jpg\u0026quot; ) ); // ...or write this straight to stdout, if we don't need the memory info require \u0026quot;memory.php\u0026quot;; 设想一下，一个路由应用程序让我们看到这段代码。但是，我们想从CDN获取一个文件，而不是从本地的文件系统获取。我们可以用一些其他的东西来更好的替换file_get_contents（就像Guzzle），即使在引擎内部它们几乎是一样的。\n图片的内存大概有581K。现在，让我们来试试这个\n// from piping-files-4.php $handle1 = fopen( \u0026quot;https://github.com/assertchris/uploads/raw/master/rick.jpg\u0026quot;, \u0026quot;r\u0026quot; ); $handle2 = fopen( \u0026quot;piping-files-4.jpeg\u0026quot;, \u0026quot;w\u0026quot; ); // ...or write this straight to stdout, if we don't need the memory info stream_copy_to_stream($handle1, $handle2); fclose($handle1); fclose($handle2); require \u0026quot;memory.php\u0026quot;; 内存使用明显变少（大概400K），但是结果是一样的。如果我们不关注内存信息，我们依旧可以用标准模式输出。实际上，PHP提供了一个简单的方式来完成：\n$handle1 = fopen( \u0026quot;https://github.com/assertchris/uploads/raw/master/rick.jpg\u0026quot;, \u0026quot;r\u0026quot; ); $handle2 = fopen( \u0026quot;php://stdout\u0026quot;, \u0026quot;w\u0026quot; ); stream_copy_to_stream($handle1, $handle2); fclose($handle1); fclose($handle2); // require \u0026quot;memory.php\u0026quot;; 其它流 还有其它一些流，我们可以通过管道来写入和读取（或只读取/只写入）：\nphp://stdin (只读) php://stderr (只写, 如php://stdout) php://input (只读) 这使我们能够访问原始请求体 php://output (只写) 让我们写入输出缓冲区 php://memory 和 php://temp (读-写) 是我们可以临时存储数据的地方。 不同之处在于一旦它变得足够大 php://temp 会将数据存储在文件系统中，而 php://memory 将一直持存储在内存中直到资源耗尽。 过滤器 还有一个我们可以在stream上使用的技巧，称为过滤器。它们是一种中间的步骤，提供对stream数据的一些控制，但不把他们暴露给我们。想象一下，我们会使用Zip扩展名来压缩我们的shakespeare.txt文件。\n// from filters-1.php $zip = new ZipArchive(); $filename = \u0026quot;filters-1.zip\u0026quot;; $zip-\u0026gt;open($filename, ZipArchive::CREATE); $zip-\u0026gt;addFromString(\u0026quot;shakespeare.txt\u0026quot;, file_get_contents(\u0026quot;shakespeare.txt\u0026quot;)); $zip-\u0026gt;close(); require \u0026quot;memory.php\u0026quot;; 这是一小段整洁的代码，但它测量内存占用在10.75MB左右。使用过滤器的话，我们可以减少内存：\n// from filters-2.php $handle1 = fopen( \u0026quot;php://filter/zlib.deflate/resource=shakespeare.txt\u0026quot;, \u0026quot;r\u0026quot; ); $handle2 = fopen( \u0026quot;filters-2.deflated\u0026quot;, \u0026quot;w\u0026quot; ); stream_copy_to_stream($handle1, $handle2); fclose($handle1); fclose($handle2); require \u0026quot;memory.php\u0026quot;; 此处，我们可以看到名为php://filter/zlib.deflate的过滤器，它读取并压缩资源的内容。我们可以在之后将压缩数据导出到另一个文件中。这仅使用了896KB.\n我知道这是不一样的格式，或者制作zip存档是有好处的。你不得不怀疑：如果你可以选择不同的格式并节省约12倍的内存，为什么不选呢？\n为了解压此数据，我们可以通过执行另一个zlib filter将压缩后的数据还原：\n// from filters-2.php file_get_contents( \u0026quot;php://filter/zlib.inflate/resource=filters-2.deflated\u0026quot; ); Streams have been extensively covered in Stream在“理解PHP中的流”和“高效使用PHP中的流”中已经被全面介绍了。如果你喜欢一个完全不同的视角，可以阅读一下。\n定制流 fopen和file_get_contents有它们自己的一套默认选项，但是这些都是完全可定制的。为了定义它们，我们需要创建一个新的流上下文：\n// from creating-contexts-1.php $data = join(\u0026quot;\u0026amp;\u0026quot;, [ \u0026quot;twitter=assertchris\u0026quot;, ]); $headers = join(\u0026quot;\\r\\n\u0026quot;, [ \u0026quot;Content-type: application/x-www-form-urlencoded\u0026quot;, \u0026quot;Content-length: \u0026quot; . strlen($data), ]); $options = [ \u0026quot;http\u0026quot; =\u0026gt; [ \u0026quot;method\u0026quot; =\u0026gt; \u0026quot;POST\u0026quot;, \u0026quot;header\u0026quot;=\u0026gt; $headers, \u0026quot;content\u0026quot; =\u0026gt; $data, ], ]; $context = stream_content_create($options); $handle = fopen(\u0026quot;https://example.com/register\u0026quot;, \u0026quot;r\u0026quot;, false, $context); $response = stream_get_contents($handle); fclose($handle); 在这个例子中，我们正在尝试向API发出POST请求。 API终端是安全的，但我们仍然需要使用http上下文属性（用于http和https）。我们设置一些消息头参数，并打开一个文件句柄到API。由于上下文处理写操作，我们可以将句柄打开为只读。\n查看文档了解更多。\n制定自定义协议和过滤器 在我们结束之前，让我们谈谈制定自定义协议。 如果你查看文档，你可以找到一个示例类来实现：\nProtocol { public resource $context; public __construct ( void ) public __destruct ( void ) public bool dir_closedir ( void ) public bool dir_opendir ( string $path , int $options ) public string dir_readdir ( void ) public bool dir_rewinddir ( void ) public bool mkdir ( string $path , int $mode , int $options ) public bool rename ( string $path_from , string $path_to ) public bool rmdir ( string $path , int $options ) public resource stream_cast ( int $cast_as ) public void stream_close ( void ) public bool stream_eof ( void ) public bool stream_flush ( void ) public bool stream_lock ( int $operation ) public bool stream_metadata ( string $path , int $option , mixed $value ) public bool stream_open ( string $path , string $mode , int $options , string \u0026amp;$opened_path ) public string stream_read ( int $count ) public bool stream_seek ( int $offset , int $whence = SEEK_SET ) public bool stream_set_option ( int $option , int $arg1 , int $arg2 ) public array stream_stat ( void ) public int stream_tell ( void ) public bool stream_truncate ( int $new_size ) public int stream_write ( string $data ) public bool unlink ( string $path ) public array url_stat ( string $path , int $flags ) } 我们不打算实现其中的一个，因为我认为它应该有自己的教程。这里有很多工作需要完成。但是一旦这个工作完成，我们可以很容易地注册我们的流包装：\nif (in_array(\u0026quot;highlight-names\u0026quot;, stream_get_wrappers())) { stream_wrapper_unregister(\u0026quot;highlight-names\u0026quot;); } stream_wrapper_register(\u0026quot;highlight-names\u0026quot;, \u0026quot;HighlightNamesProtocol\u0026quot;); $highlighted = file_get_contents(\u0026quot;highlight-names://story.txt\u0026quot;); 同样，也可以创建自定义流过滤器。该文档有一个示例过滤器类：\nFilter { public $filtername; public $params public int filter ( resource $in , resource $out , int \u0026amp;$consumed , bool $closing ) public void onClose ( void ) public bool onCreate ( void ) } 这可以很容易地注册：\n$handle = fopen(\u0026quot;story.txt\u0026quot;, \u0026quot;w+\u0026quot;); stream_filter_append($handle, \u0026quot;highlight-names\u0026quot;, STREAM_FILTER_READ); 突出显示名称需要匹配新的筛选器类的filtername属性。也可以在php：//filter/highligh-names/resource=story.txt字符串中使用自定义过滤器。定义过滤器比定义协议要容易得多。因为协议需要处理目录操作，而过滤器只需处理每个数据块。\n如果你有这个想法，我强烈建议你尝试创建自定义协议和过滤器。如果你可以将过滤器应用于stream_copy_to_streamoperations，那么即使在使用大容量文件时，你的应用程序也可以在没有内存的情况下使用。想象一下，编写一个调整大小的图像过滤器或加密的应用程序过滤器。\n总结 虽然这不是我们经常遇到的问题，但在处理大文件时很容易搞砸。在异步应用程序中，当我们不注意小心使用内存的话，很容易导致整个服务器宕机。 本教程希望向你介绍一些新的想法（或者让你重新认识他们），以便你可以更多地考虑如何高效地读取和写入大型文件。当我们开始熟悉流程和生成器，并停止使用像file_get_contents这样的函数时，我们的应用程序中就会减少错误的类别，这看起来是很好。\n","permalink":"https://lorenwe.eu.org/posts/tech/%E5%A6%82%E4%BD%95%E7%94%A8php%E8%AF%BB%E5%8F%96%E5%A4%A7%E6%96%87%E4%BB%B6/","summary":"\u003cp\u003e在 \u003ca href=\"https://github.com/sitepoint-editors/sitepoint-performant-reading-of-big-files-in-php\"\u003eGitHub\u003c/a\u003e 上可以找到本教程的源码。\u003c/p\u003e\n\u003ch3 id=\"衡量成功的标准\"\u003e衡量成功的标准\u003c/h3\u003e\n\u003cp\u003e确保我们对代码有改进的唯一方法是测试一个不好的情况，然后将我们修复之后的测量与另一个进行比较。换句话说，除非我们知道“解决方案”对我们有多大的帮助（如果有的话），否则我们不知道它是否真的是一个解决方案。\u003c/p\u003e\n\u003cp\u003e这里有两个我们可以关系的衡量标准。首先是CPU使用率。我们要处理的进程有多快或多慢？第二是内存使用情况。脚本执行时需要多少内存？这两个通常是成反比的 - 这意味着我们可以以CPU使用率为代价来降低内存使用，反之亦然。\u003c/p\u003e","title":"如何用PHP读取大文件"},{"content":"前言 HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。\n我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行请求行、请求头、消息主体。类似于下面这样：\n\u0026lt;method\u0026gt; \u0026lt;request-URL\u0026gt; \u0026lt;version\u0026gt; \u0026lt;headers\u0026gt; \u0026lt;entity-body\u0026gt; 协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。\n但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们。\napplication/x-www-form-urlencoded 这应该是最常见的 POST 提交数据的方式了。浏览器的原生 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：\nPOST http://www.example.com HTTP/1.1 Content-Type: application/x-www-form-urlencoded;charset=utf-8 title=test\u0026amp;sub%5B%5D=1\u0026amp;sub%5B%5D=2\u0026amp;sub%5B%5D=3 首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1\u0026amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。例如 PHP 中，$_POST['title'] 可以获取到 title 的值，$_POST['sub'] 可以得到 sub 数组。\n很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8」。\nmultipart/form-data 这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 \u0026lt;form\u0026gt; 表单的 enctype 等于 multipart/form-data。直接来看一个请求示例：\nPOST http://www.example.com HTTP/1.1 Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=\u0026quot;text\u0026quot; title ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=\u0026quot;file\u0026quot;; filename=\u0026quot;chrome.png\u0026quot; Content-Type: image/png PNG ... content of chrome.png ... ------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束。关于 multipart/form-data 的详细定义，请前往 rfc1867 查看。\n这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。\n上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 \u0026lt;form\u0026gt; 表单也只支持这两种方式（通过 \u0026lt;form\u0026gt; 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。\n随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。\napplication/json application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。\nJSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。\nGoogle 的 AngularJS 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码：\nvar data = {'title':'test', 'sub' : [1,2,3]}; $http.post(url, data).success(function(result) { ... }); 最终发送的请求是：\nPOST http://www.example.com HTTP/1.1 Content-Type: application/json;charset=utf-8 {\u0026quot;title\u0026quot;:\u0026quot;test\u0026quot;,\u0026quot;sub\u0026quot;:[1,2,3]} 这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。一些 php 框架已经开始这么做了。\n当然 AngularJS 也可以配置为使用 x-www-form-urlencoded 方式提交数据。\ntext/xml 它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的：\nPOST http://www.example.com HTTP/1.1 Content-Type: text/xml \u0026lt;?xml version=\u0026quot;1.0\u0026quot;?\u0026gt; \u0026lt;methodCall\u0026gt; \u0026lt;methodName\u0026gt;examples.getStateName\u0026lt;/methodName\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt;\u0026lt;i4\u0026gt;41\u0026lt;/i4\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/methodCall\u0026gt; XML-RPC 协议简单、功能够用，各种语言的实现都有。JavaScript 中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。不过，我个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。\n","permalink":"https://lorenwe.eu.org/posts/tech/%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84post%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F/","summary":"\u003ch3 id=\"前言\"\u003e前言\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://www.ietf.org/rfc/rfc2616.txt\"\u003eHTTP/1.1\u003c/a\u003e 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。\u003c/p\u003e\n\u003cp\u003e我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行请求行、请求头、消息主体。类似于下面这样：\u003c/p\u003e","title":"四种常见的POST提交数据方式"},{"content":"引言 最近在尝试基于 PHP 做一个反向代理 HTTP 的程序，其中一个需求是将程序收到的HTTP请求还原回 RFC2616 的原始格式。\n在处理的过程中遇到的问题主要在请求体的处理上。利用PHP的封装协议机制，我们可以通过读取 php://input 访问原始的POST信息。但这种方式有一个局限，对于 multipart/form-data 的请求来说，为了支持文件上传的操作，PHP会预先把请求体中的文件暂存到临时文件夹，并把参数解析到变量 $_POST 和 $_FILES 中， php://input 获取原始请求的功能也随之失效。\nStack Overflow 上的相关问题给出的 解决办法 是修改服务器配置，把发到 PHP 脚本的 Content-Type: multipart/form-data; boundary=xxxx 修改为其它格式，使其不经过PHP的 form-data 解析；或是把 php.ini 配置关于POST数据解析的 enable_post_data_reading = Off 选项关闭。然而这两种方法并不非常具有普遍性，在某些PHP配置文件不可控的共享主机的环境下并不适用。\n于是引出了本文讨论的话题 — 如何重新组装 multipart/form-data 格式的原始 POST 请求体。\nmultipart/form-data 格式 在POST请求中，一般表单会通过 application/x-www-form-urlencoded 格式上传，但此格式的数据仅支持文本格式，不支持二进制文件的上传。为了支持表单 POST 文件上传，RFC1867 定义了 multipart/form-data 的数据格式，实现了通过POST请求上传表单的内容以及二进制文件数据，关于数据的形态，参考 四种常见的 POST 提交数据方式 | JerryQu 的小站 。\nRFC1867 对于 multipart/form-data 的数据格式主要在MIME RFC1521 7.2.1 小节定义的。另外，在MIME 标准 Media Types 部分 RFC2046 的 5.1.1 节中，对于 multipart-body 的格式有一个较为清晰的 BNF 范式的语法定义，简短总结如下（来自 Stack Overflow） ：\nmultipart-body := [preamble CRLF] dash-boundary CRLF body-part *encapsulation close-delimiter [CRLF epilogue] dash-boundary := \u0026quot;--\u0026quot; boundary body-part := MIME-part-headers [CRLF *OCTET] encapsulation := delimiter CRLF body-part delimiter := CRLF dash-boundary close-delimiter := delimiter \u0026quot;--\u0026quot; 还原 multipart/form-data 的代码 写代码前搜索前人的经验，在 SegmentFault 看到了一位前辈的实现，参考前辈的代码，以及 RFC2046 的 BNF 语法定义，写了以下代码：\n// 还原 rfc1867, rfc2046 格式的FormData function getFormData() { // body-part array $body = array(); // 普通参数 foreach ($_POST as $key =\u0026gt; $value) { $body_part = \u0026quot;Content-Disposition: form-data; name=\\\u0026quot;$key\\\u0026quot;\\r\\n\u0026quot;; $body_part .= \u0026quot;\\r\\n$value\u0026quot;; $body[] = $body_part; } // 上传文件处理 foreach ($_FILES as $key =\u0026gt; $value) { $body_part = \u0026quot;Content-Disposition: form-data; name=\\\u0026quot;$key\\\u0026quot;; filename=\\\u0026quot;{$value['name']}\\\u0026quot;\\r\\n\u0026quot;; $body_part .= \u0026quot;Content-type: {$value['type']}\\r\\n\u0026quot;; $body_part .= \u0026quot;\\r\\n\u0026quot;.file_get_contents($value['tmp_name']); $body[] = $body_part; } // 提取boundary $boundary = substr($_SERVER['CONTENT_TYPE'], strpos($_SERVER['CONTENT_TYPE'], \u0026quot;=\u0026quot;) + 1); // multipart-body $multipart_body = \u0026quot;--$boundary\\r\\n\u0026quot;; // 拼接各个域 $multipart_body .= implode(\u0026quot;\\r\\n--$boundary\\r\\n\u0026quot;, $body); // 最后一个不同的 boundary $multipart_body .= \u0026quot;\\r\\n--$boundary--\u0026quot;; return $multipart_body; } 数组类型参数的支持 以上代码在大多数情况下工作正常，但未考虑到请求参数的类型为数组的情况。\n在PHP解释器源码的测试用例中，我们可以找到许多数组类型参数的测试，部分摘录如下：\na[]=1 a[]=1\u0026amp;a[]=1 a[]=1\u0026amp;a[0]=5 a[a]=1\u0026amp;a[b]=3 a[]=1\u0026amp;a[a]=1\u0026amp;a[b]=3 a[][]=1\u0026amp;a[][]=3\u0026amp;b[a][b][c]=1\u0026amp;b[a][b][d]=1 a=1\u0026amp;b=ZYX\u0026amp;c[][][][][][][][][][][][][][][][][][][][][][]=123\u0026amp;d=123\u0026amp;e[][]][]=3 Content-Type: multipart/form-data; boundary=---------------------------20896060251896012921717172737 -----------------------------20896060251896012921717172737 Content-Disposition: form-data; name=\u0026quot;file[]\u0026quot;; filename=\u0026quot;file1.txt\u0026quot; Content-Type: text/plain-file1 1 -----------------------------20896060251896012921717172737 Content-Disposition: form-data; name=\u0026quot;file[2]\u0026quot;; filename=\u0026quot;file2.txt\u0026quot; Content-Type: text/plain-file2 2 -----------------------------20896060251896012921717172737 Content-Disposition: form-data; name=\u0026quot;file[]\u0026quot;; filename=\u0026quot;file3.txt\u0026quot; Content-Type: text/plain-file3 3 -----------------------------20896060251896012921717172737-- 在PHP源码的 main/php_variables.c 中的 php_register_variable_ex 函数中，我们可以看到相关的处理：\n/* 99-110行 */ /* ensure that we don't have spaces or dots in the variable name (not binary safe) */ for (p = var; *p; p++) { if (*p == ' ' || *p == '.') { *p='_'; } else if (*p == '[') { is_array = 1; ip = p; *p = 0; break; } } var_len = p - var; /* 229-235行 */ ip++; if (*ip == '[') { is_array = 1; *ip = 0; } else { goto plain_var; } 可见，在还原POST数据的时候，我们还需要考虑到参数为数组的情况。\n这里通过一个简单的 DFS 算法深度优先遍历数组，生成类似 a[0], a[1][1] 的字符串来实现：\n\u0026lt;?php $arr = [ 'key1' =\u0026gt; [ '_key1' =\u0026gt; 23333, '_key2' =\u0026gt; 66666, ], 'key2' =\u0026gt; \u0026quot;hahah\u0026quot;, \u0026quot;test\u0026quot;, ]; var_dump($arr); function dfs(\u0026amp;$node, $prefix, \u0026amp;$result) { if (!is_array($node)) { $result[$prefix] = $node; } else { foreach ($node as $key =\u0026gt; $value) { dfs($value, \u0026quot;{$prefix}[{$key}]\u0026quot;, $result); } } } dfs($arr, \u0026quot;arr\u0026quot;, $result); foreach ($result as $key =\u0026gt; $value) { echo \u0026quot;$key = $value\\n\u0026quot;; } 运行结果：\narray(3) { [\u0026quot;key1\u0026quot;]=\u0026gt; array(2) { [\u0026quot;_key1\u0026quot;]=\u0026gt; int(23333) [\u0026quot;_key2\u0026quot;]=\u0026gt; int(66666) } [\u0026quot;key2\u0026quot;]=\u0026gt; string(5) \u0026quot;hahah\u0026quot; [0]=\u0026gt; string(4) \u0026quot;test\u0026quot; } arr[key1][_key1] = 23333 arr[key1][_key2] = 66666 arr[key2] = hahah arr[0] = test 至于 $_FILES 数组，这里有一个反直觉的情况，具体在文档中也有人提出： PHP: POST method uploads - Manual\n简单地说，当表单中文件域的key为数组形式时，拿到的 $_FILES 数组类似如下的格式：\narray(1) { [\u0026quot;key\u0026quot;]=\u0026gt; array(5) { [\u0026quot;name\u0026quot;]=\u0026gt; array(2) { [0]=\u0026gt; string(8) \u0026quot;test.txt\u0026quot; [1]=\u0026gt; array(1) { [0]=\u0026gt; string(8) \u0026quot;test.txt\u0026quot; } } [\u0026quot;type\u0026quot;]=\u0026gt; array(2) { [0]=\u0026gt; string(10) \u0026quot;text/plain\u0026quot; [1]=\u0026gt; array(1) { [0]=\u0026gt; string(10) \u0026quot;text/plain\u0026quot; } } [\u0026quot;tmp_name\u0026quot;]=\u0026gt; array(2) { [0]=\u0026gt; string(14) \u0026quot;/tmp/phpKHCoSt\u0026quot; [1]=\u0026gt; array(1) { [0]=\u0026gt; string(14) \u0026quot;/tmp/phpSgtRHe\u0026quot; } } [\u0026quot;error\u0026quot;]=\u0026gt; array(2) { [0]=\u0026gt; int(0) [1]=\u0026gt; array(1) { [0]=\u0026gt; int(0) } } [\u0026quot;size\u0026quot;]=\u0026gt; array(2) { [0]=\u0026gt; int(8) [1]=\u0026gt; array(1) { [0]=\u0026gt; int(8) } } } } 假设我的目标是 key[1][0] 的 name 属性，在PHP中我们需要通过 $_FILES[\u0026ldquo;key\u0026rdquo;][\u0026ldquo;name\u0026rdquo;][1][0] 来访问，而在 $_FILES[\u0026ldquo;key\u0026rdquo;][\u0026ldquo;name\u0026rdquo;] 中，后面的索引的层级并不确定的，我们也不能简单地指定 [1][0] 来访问 $_FILES[\u0026ldquo;key\u0026rdquo;][\u0026ldquo;name\u0026rdquo;][1][0]。所以这里得有一些 hack 来优化一下这个过程，这里我实现了一个 query_multidimensional_array 函数，具体看最终的代码。\ngetFormData() 代码实现 以下是整个函数的完整实现：\n// 还原 rfc1867, rfc2046 格式的FormData function getFormData() { // body-part array $body = array(); // 普通参数 foreach ($_POST as $key =\u0026gt; $value) { if (!is_array($value)) { $body_part = \u0026quot;Content-Disposition: form-data; name=\\\u0026quot;$key\\\u0026quot;\\r\\n\u0026quot;; $body_part .= \u0026quot;\\r\\n$value\u0026quot;; $body[] = $body_part; } else { // 数组的情况处理 如 param1[]=xxxx $result = array(); convert_array_key($value, $key, $result); foreach ($result as $k =\u0026gt; $v) { $body_part = \u0026quot;Content-Disposition: form-data; name=\\\u0026quot;$k\\\u0026quot;\\r\\n\u0026quot;; $body_part .= \u0026quot;\\r\\n$v\u0026quot;; $body[] = $body_part; } } } // 上传文件处理 foreach ($_FILES as $key =\u0026gt; $value) { if (!is_array($value['type'])) { $body_part = \u0026quot;Content-Disposition: form-data; name=\\\u0026quot;$key\\\u0026quot;; filename=\\\u0026quot;{$value['name']}\\\u0026quot;\\r\\n\u0026quot;; $body_part .= \u0026quot;Content-type: {$value['type']}\\r\\n\u0026quot;; $body_part .= \u0026quot;\\r\\n\u0026quot;.file_get_contents($value['tmp_name']); $body[] = $body_part; } else { // 文件key是数组的情况 如 file1[]=xxxx $result = array(); convert_array_key($value['type'], \u0026quot;\u0026quot;, $result); foreach ($result as $k =\u0026gt; $v) { $filename = query_multidimensional_array($value['name'], $k); $type = query_multidimensional_array($value['type'], $k); $tmp_name = query_multidimensional_array($value['tmp_name'], $k); $body_part = \u0026quot;Content-Disposition: form-data; name=\\\u0026quot;{$key}{$k}\\\u0026quot;; filename=\\\u0026quot;{$filename}\\\u0026quot;\\r\\n\u0026quot;; $body_part .= \u0026quot;Content-type: {$type}\\r\\n\u0026quot;; $body_part .= \u0026quot;\\r\\n\u0026quot;.file_get_contents($tmp_name); $body[] = $body_part; } } } // 提取boundary $boundary = substr($_SERVER['CONTENT_TYPE'], strpos($_SERVER['CONTENT_TYPE'], \u0026quot;=\u0026quot;) + 1); // multipart-body $multipart_body = \u0026quot;--$boundary\\r\\n\u0026quot;; // 拼接各个域 $multipart_body .= implode(\u0026quot;\\r\\n--$boundary\\r\\n\u0026quot;, $body); // 最后一个不同的 boundary $multipart_body .= \u0026quot;\\r\\n--$boundary--\u0026quot;; return $multipart_body; } // 直接访问多维数组元素 // query: [0][0] -\u0026gt; $array[0][0] function query_multidimensional_array(\u0026amp;$array, $query) { $query = explode('][', substr($query, 1, -1)); $temp = $array; foreach ($query as $key) { $temp = $temp[$key]; } return $temp; } // DFS将数组变为一维形式 function convert_array_key(\u0026amp;$node, $prefix, \u0026amp;$result) { if (!is_array($node)) { $result[$prefix] = $node; } else { foreach ($node as $key =\u0026gt; $value) { convert_array_key($value, \u0026quot;{$prefix}[{$key}]\u0026quot;, $result); } } } 至此，在PHP脚本中，只需调用 getFormData() ，即可获得 multipart/form-data 请求的原始数据，通过以下代码可以实现一键获取请求原始POST Body。\n需要注意的是，若数组类型参数是 a[] 这种形式，经过本函数还原后会补充具体的下标，比如说这里的 a[] 会被处理成 a[0] ，a[][] 则为 a[0][0]。从而导致了 POST Body 长度发生变化，若结果需要用于发包等操作，我们需要重新计算 Content-Length ，避免请求出现问题。\nif (@$_SERVER['CONTENT_TYPE'] \u0026amp;\u0026amp; strpos($_SERVER['CONTENT_TYPE'], \u0026quot;multipart/form-data\u0026quot;) !== false) { $body = getFormData(); $content_length = strlen($body); } else { $body = file_get_contents('php://input'); } PHP中以multipart/form-data上传文件流 上传类:\nclass UploadPart { protected static $url; protected static $delimiter; protected static $instance; public function __construct() { static::$url = '上传地址'; static::$delimiter = uniqid(); // 生成 } public function putPart($param) { $post_data = static::buildData($param); $curl = curl_init(static::$url); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl, CURLOPT_POST, true); curl_setopt($curl, CURLOPT_POSTFIELDS, $post_data); curl_setopt($curl, CURLOPT_HTTPHEADER, [ \u0026quot;Content-Type: multipart/form-data; boundary=\u0026quot; . static::$delimiter, \u0026quot;Content-Length: \u0026quot; . strlen($post_data) ]); $response = curl_exec($curl); curl_close($curl); $info = json_decode($response, true); if (!is_array($info['Msg']) \u0026amp;\u0026amp; $info['Msg'] == $param['filesize']) { $param['offset'] = $param['filesize']; $param['upload'] = ''; return $this-\u0026gt;putPart($param); } return $response; } private static function buildData($param){ $data = ''; $eol = \u0026quot;\\r\\n\u0026quot;; $upload = $param['upload']; unset($param['upload']); foreach ($param as $name =\u0026gt; $content) { $data .= \u0026quot;--\u0026quot; . static::$delimiter . \u0026quot;\\r\\n\u0026quot; . 'Content-Disposition: form-data; name=\u0026quot;' . $name . \u0026quot;\\\u0026quot;\\r\\n\\r\\n\u0026quot; . $content . \u0026quot;\\r\\n\u0026quot;; } // 拼接文件流 $data .= \u0026quot;--\u0026quot; . static::$delimiter . $eol . 'Content-Disposition: form-data; name=\u0026quot;upload\u0026quot;; filename=\u0026quot;' . $param['filename'] . '\u0026quot;' . \u0026quot;\\r\\n\u0026quot; . 'Content-Type:application/octet-stream'.\u0026quot;\\r\\n\\r\\n\u0026quot;; $data .= $upload . \u0026quot;\\r\\n\u0026quot;; $data .= \u0026quot;--\u0026quot; . static::$delimiter . \u0026quot;--\\r\\n\u0026quot;; return $data; } public static function getInstance() { if(!static::$instance){ static::$instance = new static(); } return static::$instance; } } 使用方法\n$fields = array( 'type' =\u0026gt; 'video', 'filename' =\u0026gt; '1407.png', 'filesize' =\u0026gt; 58701, 'offset' =\u0026gt; 0, 'filetype' =\u0026gt; '.acc', 'originName' =\u0026gt; '1407.png', 'upload'=\u0026gt;file_get_contents('0407.png') ); $part = UploadPart::getInstance()-\u0026gt;putPart($fields); 参考 RFC1521 RFC1867 RFC2046 PHP: POST 方法上传 - Manual PHP: 上传多个文件 - Manual PHP文件上传源码分析(RFC1867) | 风雪之隅 深入理解PHP原理之文件上传 | 风雪之隅 四种常见的 POST 提交数据方式 | JerryQu 的小站 php - Get raw post data - Stack Overflow http - Is this a well formed multipart/form-data request? - Stack Overflow http - 请问哪份 RFC 文档定义了 multipart/form-data 的格式？ - SegmentFault 思否 ","permalink":"https://lorenwe.eu.org/posts/tech/php%E6%9E%84%E9%80%A0form-data%E6%A0%BC%E5%BC%8Fpost%E8%AF%B7%E6%B1%82%E4%BD%93%E7%9A%84%E6%96%B9%E6%B3%95/","summary":"\u003ch3 id=\"引言\"\u003e引言\u003c/h3\u003e\n\u003cp\u003e最近在尝试基于 PHP 做一个反向代理 HTTP 的程序，其中一个需求是将程序收到的HTTP请求还原回 \u003ca href=\"https://www.ietf.org/rfc/rfc2616.txt\"\u003eRFC2616\u003c/a\u003e 的原始格式。\u003c/p\u003e\n\u003cp\u003e在处理的过程中遇到的问题主要在请求体的处理上。利用PHP的封装协议机制，我们可以通过读取 \u003ca href=\"https://www.php.net/manual/zh/wrappers.php.php\"\u003ephp://input\u003c/a\u003e 访问原始的POST信息。但这种方式有一个局限，对于 multipart/form-data 的请求来说，为了支持文件上传的操作，PHP会预先把请求体中的文件暂存到临时文件夹，并把参数解析到变量 $_POST 和 $_FILES 中， php://input 获取原始请求的功能也随之失效。\u003c/p\u003e","title":"PHP构造multipart/form-data格式POST请求体的方法"},{"content":"一、为什么要配置多个Git账号 文章写于2021年的最后一天，最近闲来无事，想搞个导航网站，至于为什么要自己搞，纯属兴趣，既然是兴趣，就想着不要投入太大，整个省心省力的方案，github pages走起，问题就来了，一个github账号只能CANAME一个域名，我刚好挂了一个博客，其他的仓库要pages就只能在我的博客域名后面跟上仓库名这样访问，这很不程序员，所以我就又注册了一个github账号，现在在我的win10电脑上就要使用两个github账户了，当我在我的电脑上给新注册的仓库推送代码时就会出现当前用户没有权限访问，至此，就只能想办法配置好多个用户访问了，其实实际工作中也会遇见这个问题，比如自己肯定有github账户，开发公司项目的时候可能会有公司的gitlab账户或者其他代码仓库的账户，如果是使用http方式拉取代码还好，账户密码一输，记住密码也就没有后续问题了，但如果是使用ssh拉取代码就懵逼了，今天就是来解决这个问题的\n二、初始化Git配置 默认我们都是已经使用了很久git，肯定做过很多设置了，为解决上面这个问题呢主要就是让git不再以一个用户身份对仓库进行更改，而是让它自动的选择对应的用户身份去操作代码仓库，只要用户身份和仓库对应上了，就没有权限问题啦，那就开干吧！\n1.去除全局用户配置 # 设置全局用户名 git config --golbal user.name \u0026quot;XXX\u0026quot; # 设置全局邮箱 git config --golbal user.email \u0026quot;xxx@aa.com\u0026quot; # 查看全局用户名 git config --global user.name # 查看全局邮箱 git config --global user.email # 查看全局密码 git config --global user.password 移除全局配置的用户信息\n# 移除全局配置账户 git config --global --unset user.name # 移除全局配置邮箱 git config --global --unset user.email # 移除全局密码 git config --global --unset user.password 如果上述命令执行有问题的话其实还可以自行更改git配置文件来实现\n如：找到C:\\Users\\Administrator\\.gitconfig文件，用文本编辑器打开找到[user]这一栏把所有的用户及邮箱信息删掉，就像这样：\n[user] [http] sslVerify = false 接下来运行命令来检查一下配置是否成功 git config --list\n$ git config --list core.symlinks=false core.autocrlf=true core.fscache=true color.diff=auto color.status=auto color.branch=auto color.interactive=true help.format=html rebase.autosquash=true http.sslbackend=openssl http.sslcainfo=C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt credential.helper=manager http.sslverify=false 没有看到用户信息就算完成了\n2.生成密钥对 因为是要通过ssh来推拉仓库，故我们要先生成ssh的key，生成的命令也很简单\nssh-keygen -t rsa -C \u0026quot;lorenwe@163.com\u0026quot; 在这先声明一下自己的用户体系，以后后面搞混乱了，我原来自有一个github账户名是lorenwe，现在又注册了一个名为lorenwe2的账户（取名是个麻烦事），邮箱呢都是用的163的，所以两个账户的邮箱是lorenwe@163.com和lorenwe2@163.com，接下来就是不同的操作来啦\n注意上面那条命令 ssh-keygen -t rsa -C \u0026quot;lorenwe@163.com\u0026quot; 执行完后会在用户目录也就是C:\\Users\\Administrator 目录的 .ssh 目录里面生成两个文件名为 id_rsa 和 id_rsa.pub 的两个文件，如果在执行命令前就有的话可能你之前已经配置了ssh key，如果知道key对应配置哪个网站的话，可以删除从新配置，如果不支持重新配置的话就不建议删除了，\n可以使用这个命令生成指定文件名的密钥对\nssh-keygen -t rsa -C \u0026quot;lorenwe@163.com\u0026quot; -f id_rsa_lorenwe 现在我们不指定，也就是说生成了上面所说的两个文件，然后对这两个文件进行重命名，为了好区分我就直接在后面加上用户名了，现在文件结构如下：\n接下来就是为第二个用户生成 ssh key，重复以上操作即可\nAdministrator@PC-20210304RNJZ MINGW64 ~/.ssh $ ssh-keygen -t rsa -C \u0026quot;lorenwe2@163.com\u0026quot; -f id_rsa_lorenwe2 Generating public/private rsa key pair. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in id_rsa_lorenwe2. Your public key has been saved in id_rsa_lorenwe2.pub. The key fingerprint is: SHA256:DwTCt/KL3YvvLEA9AFj/8BCGyRj/00EJLM4KXe+TCZk lorenwe2@163.com The key's randomart image is: +---[RSA 2048]----+ |.*o*=.o. | |o.=o=+o. | | +.o+B... | |. +.E*=o | |.. .o=++S | |. ..* o | | + + . | | . +o. | | .+=. | +----[SHA256]-----+ 注意使用 -f 指定生成文件名时需要让命令行处于在 .ssh 目录下，因为指定文件名后生成的文件就处于命令行所在的文件夹，在 .ssh 目录下省去了再去移动文件这一步，现在我们的文件目录结构为：\n至此准备工作完成了。\n三、配置Github的 SSH 用户 lorenwe 登录 GitHub，进入【Settings】-【SSH and GPG keys】，如下截图： 点击【New SSH key】按钮，进入新建SSH key页面，复制 id_rsa_lorenwe.pub 文件内容粘贴到大框框中，如下配图： Title随便取一个，我这取的是邮箱，这样配置完了就知道我这个密钥是给哪个用户配置的\n打开另外一个浏览器登入lorenwe2 账户重复一遍上面操作即可，至此GitHub配置完成了，同样的道理我们也可以配置其他站点的 ssh key，如 gitee 等 四、测试配置是否成功 可以执行下面的命令来测试密钥配置，需要注意的是测试命令需要自己指定要使用的是哪个key，因为在.ssh目录下面有两个key，默认是使用id_rsa来验证的\nssh -T git@github.com -i ~/.ssh/id_rsa_lorenwe Hi lorenwe! You've successfully authenticated, but GitHub does not provide shell access. ssh -T git@github.com -i ~/.ssh/id_rsa_lorenwe2 Hi lorenwe2! You've successfully authenticated, but GitHub does not provide shell access. 看到 successfully 就说明成功了\n五、Git配置不同站点使用不同用户 还是在.ssh目录下，创建一个文件名为 config 的文件，注意不带后缀，不是config.txt和config.ini，不带后缀就叫config，编辑器打开然后输入以下内容：\n# 配置user1 Host lorenwe.github.com HostName github.com IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_rsa_lorenwe PreferredAuthentications publickey User lorenwe # 配置user2 Host lorenwe2.github.com HostName github.com IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_rsa_lorenwe2 PreferredAuthentications publickey User lorenwe2 假如你还要配置公司内部的gitlab用户，那么可以按照下面的配置来修改\n# 配置user3 Host 192.168.12.5 Hostname 192.168.12.5 PreferredAuthentications publickey IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_rsa_gitlab User gitlab_name 最后.ssh目录的文件结构如下图：\n六、使用需要注意的地方 在github上创建好一个仓库，创建好后如下：\n注意到 仓库 clone 路径 ssh的方式\ngit@github.com:lorenwe2/lorenwe2.git 使用以下命令clone会发现出错了，具体如下\nAdministrator@PC-20210304RNJZ MINGW64 ~/Desktop/test $ git clone git@github.com:lorenwe2/lorenwe2.git Cloning into 'lorenwe2'... git@github.com: Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 原因就是之前配置的config中是以下配置\n# 配置user1 Host lorenwe.github.com HostName github.com IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_rsa_lorenwe PreferredAuthentications publickey User lorenwe # 配置user2 Host lorenwe2.github.com HostName github.com IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_rsa_lorenwe2 PreferredAuthentications publickey User lorenwe2 两个用户的 HostName 都一样，git就从你给的clone链接里面拿到的host name也是github.com，这时候它就不知道要用哪个用户来clone了，解决办法很简单，把host再具体一点，如：\nAdministrator@PC-20210304RNJZ MINGW64 ~/Desktop/test $ git clone git@lorenwe2.github.com:lorenwe2/lorenwe2.git Cloning into 'lorenwe2'... warning: You appear to have cloned an empty repository. 上面就clone 成功了，只是clone了一个空仓库，我们只是在github.com前面加上了用户名，那就刚好对应上了上面config配置的Host，git 就知道要用哪个用户去clone仓库了，配置里面还定义的key的路径，那key也正确，所以就正常clone下来了，再测试一下推送功能吧\nAdministrator@PC-20210304RNJZ MINGW64 ~/Desktop/test $ cd lorenwe2/ Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git status On branch master No commits yet Untracked files: (use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to include in what will be committed) test.txt nothing added to commit but untracked files present (use \u0026quot;git add\u0026quot; to track) Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git add -A Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git commit -m \u0026quot;添加文件\u0026quot; *** Please tell me who you are. Run git config --global user.email \u0026quot;you@example.com\u0026quot; git config --global user.name \u0026quot;Your Name\u0026quot; to set your account's default identity. Omit --global to set the identity only in this repository. fatal: unable to auto-detect email address (got 'Administrator@PC-20210304RNJZ.(none)') 可以发现命令执行到git commit时候就出错了，给的提示信息也很明显，没有设置全局用户名，不知道以什么用户身份去提交代码，我们不要按照他的说明来，他是要设置全局用户，但我们电脑是要使用多个用户的，所以设置全局用户显然不合适，可以使用以下命令为当前项目设置用户及邮箱\ngit config user.name \u0026quot;lorenwe2\u0026quot; git config user.email \u0026quot;lorenwe2@163.com\u0026quot; Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git config user.name \u0026quot;lorenwe2\u0026quot; Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git config user.email \u0026quot;lorenwe2@163.com\u0026quot; Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git commit -m \u0026quot;添加文件\u0026quot; [master (root-commit) 7bf22a5] 添加文件 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 test.txt Administrator@PC-20210304RNJZ MINGW64 ~/Desktop/test/lorenwe2 (master) $ git push Enumerating objects: 3, done. Counting objects: 100% (3/3), done. Writing objects: 100% (3/3), 214 bytes | 214.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To lorenwe2.github.com:lorenwe2/lorenwe2.git * [new branch] master -\u0026gt; master 从上面可以看出，推送一切也都是ok的，假如不是新的仓库，而且原先还是使用HTTPS通信，则可以修改远程仓库地址\ngit remote rm origin git remote add origin git@lorenwe2.github.com:xxx/xxxxx.git 再为这个仓库配置用户名和邮箱，就也能对旧仓库修改推送方式，如不知道旧仓库是如何配置的，可以打开仓库目录里的.git文件夹找到config文件查看即可，如图：\n打开后可看到如下类似内容\n[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true [remote \u0026quot;origin\u0026quot;] url = git@lorenwe2.github.com:lorenwe2/lorenwe2.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \u0026quot;master\u0026quot;] remote = origin merge = refs/heads/master [user] name = lorenwe2 email = lorenwe2@163.com 至此 win10 配置多个git账户算是完成啦\n","permalink":"https://lorenwe.eu.org/posts/tech/win10%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7/","summary":"\u003ch3 id=\"一为什么要配置多个git账号\"\u003e一、为什么要配置多个Git账号\u003c/h3\u003e\n\u003cp\u003e文章写于2021年的最后一天，最近闲来无事，想搞个导航网站，至于为什么要自己搞，纯属兴趣，既然是兴趣，就想着不要投入太大，整个省心省力的方案，github pages走起，问题就来了，一个github账号只能CANAME一个域名，我刚好挂了一个博客，其他的仓库要pages就只能在我的博客域名后面跟上仓库名这样访问，这很不程序员，所以我就又注册了一个github账号，现在在我的win10电脑上就要使用两个github账户了，当我在我的电脑上给新注册的仓库推送代码时就会出现当前用户没有权限访问，至此，就只能想办法配置好多个用户访问了，其实实际工作中也会遇见这个问题，比如自己肯定有github账户，开发公司项目的时候可能会有公司的gitlab账户或者其他代码仓库的账户，如果是使用http方式拉取代码还好，账户密码一输，记住密码也就没有后续问题了，但如果是使用ssh拉取代码就懵逼了，今天就是来解决这个问题的\u003c/p\u003e","title":"Win10配置多个Github账号"},{"content":" Lorenwe Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Lorenwe Blog 网址： https://lorenwe.eu.org/ 图标： https://lorenwe.eu.org/img/kaola.png 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n","permalink":"https://lorenwe.eu.org/links/","summary":"\u003cdiv class=\"friend\"\u003e\n\u003ca target=\"_blank\" href=https://lorenwe.eu.org title=Lorenwe\u0026#32;Blog class=\"friendurl\"\u003e\n  \u003cdiv class=\"frienddiv\"\u003e\n    \u003cdiv class=\"frienddivleft\"\u003e\n      \u003cimg class=\"myfriend\" src=https://lorenwe.eu.org/img/kaola.png /\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"frienddivright\"\u003e\n      \u003cdiv class=\"friendname\"\u003eLorenwe Blog\u003c/div\u003e\n      \u003cdiv class=\"friendinfo\"\u003e一个记录技术、阅读、生活的博客\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/a\u003e\n\n\u003c/div\u003e\n\u003cbr/\u003e\n\u003cbr/\u003e\n\u003cbr/\u003e\n\u003cbr/\u003e\n\u003cbr/\u003e\n\u003cdiv style=\"font-size: 20px;\" class=\"youlian\"\u003e👉友链格式\u003c/div\u003e\n\u003cdiv style=\"font-size: 16px;\"\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c/th\u003e\n          \u003cth\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e名称：\u003c/td\u003e\n          \u003ctd\u003eLorenwe Blog\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e网址：\u003c/td\u003e\n          \u003ctd\u003e\u003ca href=\"https://lorenwe.eu.org/\"\u003ehttps://lorenwe.eu.org/\u003c/a\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e图标：\u003c/td\u003e\n          \u003ctd\u003e\u003ca href=\"https://lorenwe.eu.org/img/kaola.png\"\u003ehttps://lorenwe.eu.org/img/kaola.png\u003c/a\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e描述：\u003c/td\u003e\n          \u003ctd\u003e一个记录技术、阅读、生活的博客\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003cbr/\u003e\n\u003cdiv style=\"font-size: 20px;\"\u003e👉友链申请要求\u003c/div\u003e\n\u003cblockquote\u003e\n\u003cp\u003e秉承互换友链原则、文章定期更新\u003c!-- 、网站在工信部备案 --\u003e、不能有太多广告、个人描述字数控制在15字内\u003c/p\u003e\u003c/blockquote\u003e\n\u003cbr/\u003e","title":"🤝友链"},{"content":"关于我\n英文名: Lorenwe 职业: 牛马 运动: 玩手机 ","permalink":"https://lorenwe.eu.org/about/","summary":"\u003cp style=\"font-size: 25px;\"\u003e关于我\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c/th\u003e\n          \u003cth\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e英文名:\u003c/td\u003e\n          \u003ctd\u003eLorenwe\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e职业:\u003c/td\u003e\n          \u003ctd\u003e牛马\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e运动:\u003c/td\u003e\n          \u003ctd\u003e玩手机\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"🙋🏻‍♂️关于"}]